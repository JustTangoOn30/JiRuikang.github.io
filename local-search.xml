<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>excel</title>
    <link href="/2023/01/31/office/excel/"/>
    <url>/2023/01/31/office/excel/</url>
    
    <content type="html"><![CDATA[<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>筛选：Ctrl + CapsLock + L</p><h3 id="VLOOKUP-A2-Sheet2-D-F-3-0"><a href="#VLOOKUP-A2-Sheet2-D-F-3-0" class="headerlink" title="VLOOKUP(A2,Sheet2!D:F,3,0)"></a>VLOOKUP(A2,Sheet2!D:F,3,0)</h3><p>在Sheet2的D列精确匹配与当前工作表的A2相同的单元格，并返回对应第3列（Sheet2的F列）的数据。参考：<a href="https://blog.51cto.com/u_15290190/2961174">https://blog.51cto.com/u_15290190/2961174</a></p><h3 id="合并表格"><a href="#合并表格" class="headerlink" title="合并表格"></a>合并表格</h3><p>工具栏-数据-合并表格：需要会员；<br>拆分表格等同于合并表格；</p><h3 id="重命名表格"><a href="#重命名表格" class="headerlink" title="重命名表格"></a>重命名表格</h3><p>厂名</p>]]></content>
    
    
    <categories>
      
      <category>办公软件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>common</title>
    <link href="/2022/01/05/publicstudy/common/"/>
    <url>/2022/01/05/publicstudy/common/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>根栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>logic</title>
    <link href="/2021/12/01/publicstudy/logic/"/>
    <url>/2021/12/01/publicstudy/logic/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>根栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>count</title>
    <link href="/2021/11/01/publicstudy/count/"/>
    <url>/2021/11/01/publicstudy/count/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">变量</th><th align="center">公式</th></tr></thead><tbody><tr><td align="center">基期</td><td align="center">现期-增长量；现期&#x2F;（1+增长率）</td></tr><tr><td align="center">现期</td><td align="center">基期+增长量；基期*（1+增长率）</td></tr><tr><td align="center">增长量</td><td align="center">现期-基期；基期<em>增长率； 现期</em>增长率&#x2F;(1+增长率)</td></tr><tr><td align="center">增长率</td><td align="center">增长量&#x2F;基期；增长量&#x2F;（现期-增长量）</td></tr><tr><td align="center">现期比重</td><td align="center">部分值A&#x2F;整体值B</td></tr><tr><td align="center">基期比重</td><td align="center">A<em>（1+B增长率）&#x2F;B</em>（1+A增长率）；（A-部分增长量）&#x2F;（B-整体增长量）</td></tr><tr><td align="center">比重增长量</td><td align="center">A*（A增长率-B增长率）&#x2F;（1+A增长率）</td></tr><tr><td align="center">现期倍数</td><td align="center">A是B的多少倍A&#x2F;B；A比B多&#x2F;增加（A&#x2F;B-1）倍</td></tr><tr><td align="center">基期倍数</td><td align="center">A<em>（1+B的增长率）&#x2F;B</em>（1+A的增长率）</td></tr><tr><td align="center">现期平均数</td><td align="center">总量&#x2F;份数；（部分1+部分2+……）&#x2F;份数</td></tr><tr><td align="center">基期平均数</td><td align="center">现期总量<em>（1+份增长率）&#x2F;份数总量</em>（1+总量增长率）</td></tr><tr><td align="center">平均数增长量</td><td align="center">现期总量<em>（总量增长率-份数增长率）&#x2F;份数</em>（1+总量增长率）</td></tr><tr><td align="center">平均数增长率</td><td align="center">（总量增长率-份数增长率）&#x2F;（1+份数增长率）</td></tr><tr><td align="center">隔年增长率</td><td align="center">（1+增长率）（1+上年增长率） - 1</td></tr><tr><td align="center">隔年基期值</td><td align="center">现期值&#x2F;（1+增长率）（1+上年增长率）</td></tr><tr><td align="center">年均增长量</td><td align="center">（末期值 - 基期值）&#x2F;增长次数</td></tr><tr><td align="center">年均增长率</td><td align="center">（末期值&#x2F;基期值）的根号增长次数次方-1</td></tr><tr><td align="center">贡献率</td><td align="center">部分增长量&#x2F;整体增长量</td></tr><tr><td align="center">拉动增长的百分点数</td><td align="center">部分增长量&#x2F;整体基期值；贡献率*整体增长率</td></tr><tr><td align="center">整体增长率</td><td align="center">介于多个部分增长率之间，且偏向于权重较大的一方</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>根栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>math</title>
    <link href="/2021/11/01/publicstudy/math/"/>
    <url>/2021/11/01/publicstudy/math/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>根栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>speak</title>
    <link href="/2021/10/01/publicstudy/speak/"/>
    <url>/2021/10/01/publicstudy/speak/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>根栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-原理ing</title>
    <link href="/2021/09/01/it/os2/"/>
    <url>/2021/09/01/it/os2/</url>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>程序&amp;进程&amp;线程</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="分级调度"><a href="#分级调度" class="headerlink" title="分级调度"></a>分级调度</h4><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>定义</li><li>原因</li><li>必要条件</li><li>处理</li></ul><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><h3 id="程序的装入与重定位"><a href="#程序的装入与重定位" class="headerlink" title="程序的装入与重定位"></a>程序的装入与重定位</h3><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h3 id="分页和分段存储管理"><a href="#分页和分段存储管理" class="headerlink" title="分页和分段存储管理"></a>分页和分段存储管理</h3><h3 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h3><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2>]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-概述</title>
    <link href="/2021/08/01/it/os1/"/>
    <url>/2021/08/01/it/os1/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话解释操作系统是什么"><a href="#一句话解释操作系统是什么" class="headerlink" title="一句话解释操作系统是什么"></a>一句话解释操作系统是什么</h2><p>操作系统是计算机系统中最重要的系统软件，它是控制计算机软、硬件资源和方便用户管理的程序集合。</p><h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><h3 id="无操作系统"><a href="#无操作系统" class="headerlink" title="无操作系统"></a>无操作系统</h3><h4 id="人工操作方式"><a href="#人工操作方式" class="headerlink" title="人工操作方式"></a>人工操作方式</h4><p>利用穿孔的纸带（卡片）表示数据和程序，将其事先装到输入机后启动计算机。存在用户独占、CPU等待的问题。</p><h4 id="脱机输入-x2F-输出方式"><a href="#脱机输入-x2F-输出方式" class="headerlink" title="脱机输入&#x2F;输出方式"></a>脱机输入&#x2F;输出方式</h4><p>利用<strong>外围机</strong>，输入时将程序和数据从低速的输入设备输入到磁带，当CPU需要这些数据时，再从磁带高速的读入内存，输出与其相反。<strong>减少了CPU的空闲时间，提高了I&#x2F;O速度</strong>。</p><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>系统对作业进行成批的处理</p><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>内存中始终保持一道作业，是最早的操作系统，特征有<strong>自动性、顺序性、单道性</strong>。</p><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>为了提高资源的利用率和系统吞吐量，引入多道程序设计技术，形成多道批处理系统。最典型的是<strong>并发性</strong>。<strong>资源利用率高、系统吞吐量大、平均周转时间长、无交互能力</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发：同一时间间隔</span><br><span class="line">并行：同一时刻</span><br></pre></td></tr></table></figure><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>指一台主机上连接多个带有显示器、键盘的终端，允许多个用户通过自己的终端、以交互的方式同时使用计算机，计算机按<strong>时间片</strong>分配资源<strong>共享</strong>主机中的资源。<br>特征：<strong>多路性</strong>（多个用户同时用）、<strong>交互性</strong>（在终端上编辑运行程序）、<strong>独占性</strong>（各用户互不干扰）、<strong>及时性</strong>（响应时间2-3s）。典型的是<strong>UNIX和Linux</strong>。</p><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>指能够及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的进行。特征：实时性、交互性、多路性、独立性、<strong>可靠性</strong>。比如：工业控制系统、信息查询系统、多媒体系统、嵌入式系统。</p><h3 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h3><p>在微机上配置的操作系统。</p><ul><li>单用户单任务操作系统：DOS、CP&#x2F;M</li><li>单用户多任务操作系统：95、98、早起XP</li><li>多用户多任务操作系统：win7、8、10……、UNIX、Linux</li></ul><h3 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h3><p>为网络用户提供服务，随着网络普及，现代操作系统特征之一就是上网，于是不再特指某个操作系统是网络操作系统。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>并发：计算机系统中同时存在多道运行的程序（进程）</li><li>共享：系统中的资源不再为某道程序所独占，而是供多道程序共同使用</li><li>虚拟：把一个物理实体映射为若干个对应的逻辑实体——分时或分空间</li><li>异步：也称不确定性，指进程在执行中，其执行时间、顺序、向前推进的速度和完成的时间等都是不可预知的。</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>处理机管理：对进程、线程的管理（进程控制、进程同步、进程通信、进程调度）</li><li>存储器管理：主要是为多道程序的运行提供良好的环境，有内存分配、内存保护、地址映射、虚拟内存等</li><li>设备管理：管理所有外围设备，有缓冲管理、设备分配、设备处理、虚拟设备等</li><li>文件管理：管理用户文件和系统文件，有存储空间的管理、目录管理、文件的读&#x2F;写管理、文件的共享和保护等</li><li>操作系统与用户之间的接口：有用户接口和程序接口</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>用户与计算机硬件系统之间的接口</li><li>计算机系统资源的管理者</li><li>实现对计算机资源的抽象</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>三种基本的操作系统：批处理操作系统、分时操作系统、实时操作系统，如果有其中二者称为通用操作性系统。</p>]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库-概述ing</title>
    <link href="/2021/07/01/it/sql/"/>
    <url>/2021/07/01/it/sql/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程-概述ing</title>
    <link href="/2021/06/01/it/se/"/>
    <url>/2021/06/01/it/se/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机信息安全技术-概述ing</title>
    <link href="/2021/05/01/it/security1/"/>
    <url>/2021/05/01/it/security1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-原理ing</title>
    <link href="/2021/04/01/it/network2/"/>
    <url>/2021/04/01/it/network2/</url>
    
    <content type="html"><![CDATA[<h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>传输网络数据，分为有线和无线两种。</p><h3 id="有线介质"><a href="#有线介质" class="headerlink" title="有线介质"></a>有线介质</h3><p>光缆（光纤）：带宽极大，传输速率1G-10T&#x2F;s，传输距离远，误码率低，抗干扰能力强，价格昂贵，安装困难。主要用于建筑物之间的连接。<br>双绞线：传输速率100M&#x2F;s，抗干扰能力差，价格便宜，主要用于星型网络，建筑内部的布线。<br>同轴电缆：抗干扰能力较好，传输距离比双绞线稍长，现在只是用于干扰很强的地方。<br>光缆、同轴电缆、双绞线是构建局域网的三种传输介质。普通方案是楼内双绞线，楼外同轴电缆。</p><h3 id="无线介质"><a href="#无线介质" class="headerlink" title="无线介质"></a>无线介质</h3><p>无线电波：全方向传输，使用天线，通信质量差，连接距离是全球。<br>蓝牙：无线电波的一种。10m-100m。<br>微波：直线传输，分为地面微波接力通信和卫星通信，50km<br>红外线通信：不需要天线，有方向性，不能在室外应用，市内短距离，常用于电器遥控<br>激光：传输距离远、损耗小、质量高。</p><h2 id="网络连接设备"><a href="#网络连接设备" class="headerlink" title="网络连接设备"></a>网络连接设备</h2><p>引导网络信息到达目标节点。</p><h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>网络接口卡，网络适配器，在局域网中用于将计算机与网络相连，工作在数据链路层（网线一头连网卡，一头连集线器），每块网卡有唯一固定的MAC地址。</p><h3 id="调制解调器"><a href="#调制解调器" class="headerlink" title="调制解调器"></a>调制解调器</h3><p>也叫MODEM，用于拨号上网，工作在物理层。调制是将计算机的数字信号转换为模拟信号传送出去；解调是将已调制的模拟信号转换为数字信号供计算机使用。MODEM有内置式和外置式两种，内置式如果带有LAN口其实相当于网卡。</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>是局域网中的星型连接点，Hub，扩充端口、放大信号。工作在物理层。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>Switch，即交换式集线器，是一种高性能的网络连接、数据转发设备，通常工作在数据链路层。交换机是一种用于电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。交换机是组成局域网不可缺少的硬件设备，提供局域网内多个子网互联的功能。</p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>用来连接两个或多个网段的网络互联设备。根据物理地址来过滤、存储、转发数据帧。连接两个或几个同构的局域网，工作在数据链路层。同构是指网络拓扑结构、通信协议相同。</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>Gateway，连接异构网络，不仅有路由功能，还能实现不同网络之间的协议转换功能。它可以是软件、硬件或软硬件结合，处于传输层或更高层。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>Router，主要用于局域网与广域网之间的连接，也可以用于局域网之间的连接，工作在网络层。路由器里有ARP映射表，用来根据IP地址寻址。连接因特网中各局域网、广域网的设备，根据信道的情况自动选择和设定路由，以最佳路径按前后顺序发送信号。路由器的互联能力强，可以执行复杂的路由选择算法。适合于连接复杂的大型网络。<br>家里有宽带就必须有调制解调器，有多台电脑上网就必须要路由器，假如电脑很多，超过路由器的接口数就需要交换机扩展接口。</p><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>转发器，通过放大物理信号来扩大数据传输距离，与高层协议无关，工作在物理层。</p><h3 id="三层交换机ing"><a href="#三层交换机ing" class="headerlink" title="三层交换机ing"></a>三层交换机ing</h3><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>网络协议是计算机网络和分布系统中互相通信的对等实体间交换信息时必须遵守的规则的集合。实体是指任何可发送或接收信息的硬件或软件进程。协议的组成要素有语法、语义和同步。语法定义了信息交换中信息的格式，语义定义了发送者和接受者所要完成的操作，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。同步又叫时序，是事件发生顺序的详细说明。</p><h3 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h3><p>文件传输协议，一般用于文件的上传和下载，是基于传输控制协议的服务。</p><h3 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h3><p>简单邮件传输协议，是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式，帮助每台计算机在发送或中转信件时找到下一个目的地。</p><h3 id="POP协议"><a href="#POP协议" class="headerlink" title="POP协议"></a>POP协议</h3><p>邮局协议，用于电子邮件的接收</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议，是互联网上应用最广泛的一种网络协议。互联网客户程序与服务器程序之间的交互，需要遵守的协议。所有www文件都必须遵守这个协议标准。设计HTTP协议最初是为了提供一种发布和接收HTML的方法。</p><h3 id="Telnet协议"><a href="#Telnet协议" class="headerlink" title="Telnet协议"></a>Telnet协议</h3><p>远程登录协议，主要用途是使用远程计算机上所拥有的，而本地计算机上没有的资源</p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>通过域名解析协议来转换域名和IP地址</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>用户数据报协议，应用在传输层，面向无连接的通信协议，通信时不需要连接，就可以实现广播发送；通信时也不需要接收方确认，属于不可靠的传输，在通讯过程中会出现丢包的现象。</p><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>网际协议，应用在网络层，它会给因特网中的每一台联网设备分配一个网络地址，即IP地址；并负责把数据报从源头传送到目的地，但它不负责可靠传输。</p><h3 id="ICPM网际控制报文协议"><a href="#ICPM网际控制报文协议" class="headerlink" title="ICPM网际控制报文协议"></a>ICPM网际控制报文协议</h3><p>为IP协议提供差错报告，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p><h3 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h3><p>将源主机和目的主机的逻辑地址（IP地址）与它们物理地址（MAC地址）相匹配，并确定IP地址所对应的网卡物理地址。</p><h3 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h3><p>首先，保证任何IP地址在同一时刻只能由一台DHCP客户机所使用；其次，DHCP可以给用户分配永久固定的IP地址；最后，DHCP可以用其他方法获得IP地址（如手工配置）</p><h2 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h2><h3 id="为什么使用网络参考模型"><a href="#为什么使用网络参考模型" class="headerlink" title="为什么使用网络参考模型"></a>为什么使用网络参考模型</h3><p>1、各层之间是独立的。<br>2、灵活性好。<br>3、易于实现和维护。<br>4、结构上可分割。<br>5、易于标准化。</p><h3 id="两种参考模型概述"><a href="#两种参考模型概述" class="headerlink" title="两种参考模型概述"></a>两种参考模型概述</h3><h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><p>1、物理层主要功能是对数据传输线路和传输信道进行定义。传输的数据单元称之为比特流。<br>2、数据链路层在不可靠的物理介质上提供可靠的传输，主要功能是流量控制、差错控制、帧同步、透明传输等。传输的数据单元称之为数据帧。<br>3、网络层负责对子网间的数据报进行路由选择和IP寻址。网络层提供尽最大努力的交付服务，不提供校验，允许乱序。传输的数据单元称之为IP数据报（数据报、分组、包）。<br>4、运输层是第一个端到端传输的层次，主要功能是数据分段、可靠的或不可靠的传输、差错控制和流量控制。运输层传输的数据单位为TCP报文段或UDP用户数据报。<br>5、会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。<br>6、表示层的功能包括数据的加密、压缩、格式转换等。协议有ASCII、JPEG、MPEG等。<br>7、应用层为操作系统或网络应用程序提供访问网络服务的接口。</p><h4 id="TCP-x2F-IP协议参考模型"><a href="#TCP-x2F-IP协议参考模型" class="headerlink" title="TCP&#x2F;IP协议参考模型"></a>TCP&#x2F;IP协议参考模型</h4><p>1、应用层：应用程序之间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。<br>2、传输层：在此层中，它负责应用程序间的通信和节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责数据传送数据，并且确定数据已被送达并接收。其功能包括：格式化信息流、提供可靠传输。<br>3、网络层：负责相邻计算机之间的通信，处理数据报、路径、流控、拥塞。让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。<br>4、网络接口层：定义物理介质的各种特性，定义如何使用实际网络来传送数据。处理数据帧。</p><h4 id="TCP-x2F-IP和OSI的区别"><a href="#TCP-x2F-IP和OSI的区别" class="headerlink" title="TCP&#x2F;IP和OSI的区别"></a>TCP&#x2F;IP和OSI的区别</h4><p>1、TCP&#x2F;IP解决的是多种异构网络的互联问题，OSI最初只考虑使用一种标准的公用数据网。<br>2、TCP&#x2F;IP一开始就强调面向连接和无连接服务，而OSI在开始时只强调面向连接服务。<br>3、TCP&#x2F;IP有较好的网络管理功能，并在实际中得到应用。OSI只获得了一些理论研究成果，在市场化方面并不成功。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h4 id="一句话介绍"><a href="#一句话介绍" class="headerlink" title="一句话介绍"></a>一句话介绍</h4><p>确定与传输媒体的接口的一些特性：<br>机械特性：接线器的形状、尺寸、引线数等<br>电气特性：接口电缆各条线出现的电压范围<br>功能特性：某一电平电压的意义<br>规程特性：对不同功能的各种可能事件的出现顺序</p><h4 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h4><p>信号：是数据的电气或电磁表现<br>数据：运送消息的实体<br>模拟：连续的；数字：离散的<br>信源-&gt;信道-&gt;信宿</p><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><h5 id="信息交互方式"><a href="#信息交互方式" class="headerlink" title="信息交互方式"></a>信息交互方式</h5><p>单工（单向）：广播；半双工（双向交替）：对讲机、无线电；双工（双向）：电话</p><h5 id="网络交换方式"><a href="#网络交换方式" class="headerlink" title="网络交换方式"></a>网络交换方式</h5><p>电路交换：面向连接、实时性强<br>报文交换：无需建立连接、线路利用率高、可多目标服务<br>分组交换-虚电路方式：面向连接（逻辑连接），H1给H2所有分组沿着一条虚电路传送<br>分组交换-数据报方式：面向无连接，H1给H2的分组沿不同路径传送</p><h5 id="数据传输类型"><a href="#数据传输类型" class="headerlink" title="数据传输类型"></a>数据传输类型</h5><p>局域网中距离近，用基带传输，直接传输数字信号<br>广域网需要远距离传送，将基带信号调制成频带信号传送，分为调幅、调频、调相，即将数字信号调制成模拟信号</p><h4 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h4><p>信道极限传输速率&#x3D;信道带宽 * log2(1+信噪比)<br>信噪比是指信号在传输过程中，信号的平均功率和噪声的平均功率之比<br>由此得出：<br>（1）信道带宽和最大数据传输率成正比，信噪比和最大数据传输率成正比<br>（2）实际信道上能够达到的信息传输速率要比香农的极限传输速率低</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="一句话介绍-1"><a href="#一句话介绍-1" class="headerlink" title="一句话介绍"></a>一句话介绍</h4><p>链路是指从一个节点到相邻节点的一段物理线路，中间没有任何其他交换节点。把实现控制数据传输协议的硬件和软件添加到链路上就构成了数据链路</p><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>链路管理：建立、维护、释放、链接<br>帧同步：数据前后加首、尾部使接收方从接收到的比特流中确定帧开始和结束位置<br>差错检测：水平&#x2F;垂直奇偶校验码、循环冗余校验、海明校验（纠错编码）<br>透明传输：接收方能区分正常数据和控制信息</p><h4 id="数据链路层提供的服务"><a href="#数据链路层提供的服务" class="headerlink" title="数据链路层提供的服务"></a>数据链路层提供的服务</h4><p>1、使用曼彻斯特编码<br>2、提供不可靠的交付，即尽最大努力的交付<br>3、目的站收到有差错的数据帧时丢弃、不纠错<br>4、高层发现丢失部分数据需要重传时，数据链路层不会知道这个重传的帧，会当做一个新数据帧来发送</p><h4 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h4><p>可以分为信道划分协议、随机接入协议、轮流协议</p><h5 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h5><p>频分多路复用（FDM）：每路信号以不同的载波频率进行调制，而且各个载波频率是完全独立的，即各个信道所占用的频带不相互重叠，相邻信道之间用”警戒频带“隔离，那么每个信道就能独立的传输一路信号。<br>时分多路复用（TDM）：以信道传输时间作为分割对象，通过为多个信道分配互不重叠的时间片段的方式来实现多路复用。<br>波分多路复用（WDM）：用一根光纤传输多路不同波长的信号，以提高单根光纤的传输能力<br>静态划分信道的代价高，不适合局域网</p><h5 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h5><p>传输节点总是以信道的全部速率进行发送，当有碰撞时反复的发送，直到无碰撞的通过。<br>常用的有ALOHA协议和CSMA协议</p><h6 id="载波监听多点接入-x2F-冲突检测（CSMA-x2F-CD）"><a href="#载波监听多点接入-x2F-冲突检测（CSMA-x2F-CD）" class="headerlink" title="载波监听多点接入&#x2F;冲突检测（CSMA&#x2F;CD）"></a>载波监听多点接入&#x2F;冲突检测（CSMA&#x2F;CD）</h6><p>1、许多计算机以多点接入方式连接一根总线<br>2、发送数据前先检测总线上是否有数据，没有再发，即载波监听<br>3、边发送数据边及检测信道上信号电压大小，一旦总线上出现碰撞，立即停止，并通知其他，即冲突检测<br>总之，先听后说，边听边说；一旦冲突，立即停说；等待时机，然后再说。<br>所以全双工不使用CSMA&#x2F;CD，半双工必须使用CSMA&#x2F;CD，以太网的平均通信量远小于以太网的最高数据率。适用于早起以太网，总线型网络。</p><h5 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h5><p>比较重要的轮流协议有两种，分别是轮询协议和令牌传递协议</p><h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h6><p>没有主节点，而是由一个称为令牌的小的特殊帧在节点之前以某种固定的次序进行交换</p><h4 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h4><p>是使用最多的数据链路层的协议，比如拨号上网采用的就是PPP协议；<br>不需要纠错和流量控制；<br>有三个组成部分：<br>一个将IP数据报封装到串行链路的方法<br>链路控制协议LCP<br>网络控制协议NCP</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="IP协议原理"><a href="#IP协议原理" class="headerlink" title="IP协议原理"></a>IP协议原理</h4><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><h4 id="ARP工作原理"><a href="#ARP工作原理" class="headerlink" title="ARP工作原理"></a>ARP工作原理</h4><h4 id="IP地址-amp-MAC地址-amp-ARP协同工作"><a href="#IP地址-amp-MAC地址-amp-ARP协同工作" class="headerlink" title="IP地址&amp;MAC地址&amp;ARP协同工作"></a>IP地址&amp;MAC地址&amp;ARP协同工作</h4><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><h4 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h4><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>局域网是指一个较小范围（如一个部门）内的多台计算机或者其他通信设备，通过双绞线、同轴电缆等介质互连起来，以达到资源和信息共享目的的互连网络。特点是，地理范围和站点数目优先，为一个单位所有，与采用非光纤技术的广域网相比，局域网具有较高的数据率、较低的时延和较小的误码率。IEEE802参考模型：逻辑链路控制（LLC）子层、媒体接入控制（MAC）子层。IEEE802针对物理层和数据链路层制定了一系列的协议标准。<br>优点：<br>1、具有广播功能<br>2、便于系统的扩展和演变，各个设备的位置可以灵活的调整<br>3、提高系统的可靠性、可用性、生存性<br>4、各个站点之间的关系是平等的，不存在主从关系</p><h3 id="以太网（普遍采用）"><a href="#以太网（普遍采用）" class="headerlink" title="以太网（普遍采用）"></a>以太网（普遍采用）</h3><p>以太网初期采用总线型拓扑结构，但目前的快速以太网（100BASE-T、1000BASE-T标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机来进行网络连接和组织。如此一来，以太网的拓扑结构就成了星型。但在逻辑上，以太网仍然使用总线型拓扑，这就需要用CSMA&#x2F;CD来规定多台电脑共享一个通道的方法。</p><h4 id="MAC帧"><a href="#MAC帧" class="headerlink" title="MAC帧"></a>MAC帧</h4><p>1、硬件地址&#x3D;物理地址&#x3D;MAC地址，共48位，前3字节表示生产厂家，后3字节厂家自行指派用于表示产品号<br>2、MAC帧：目的地址6B+源地址6B+类型2B+数据大于等于46B+FCS(CRC校验)4位<br>3、MAC帧间最小间隔9.6s</p><h4 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h4><p>传输速率大于等于100Mbit&#x2F;s的以太网成为高速以太网。分为100Base-T以太网（星型全双工无CSMA&#x2F;CD）和吉比特以太网（IEEE802.3标准）</p><h3 id="令牌环网（落后）"><a href="#令牌环网（落后）" class="headerlink" title="令牌环网（落后）"></a>令牌环网（落后）</h3><h3 id="虚拟局域网（新技术）"><a href="#虚拟局域网（新技术）" class="headerlink" title="虚拟局域网（新技术）"></a>虚拟局域网（新技术）</h3><p>虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。VLAN是局域网给用户提供的一种服务，并不是一个新型的局域网。VLAN是一种比较新的技术，工作在OSI参考模型的第2层和第3层，一个VLAN就是一个广播域，VLAN之间的通信是通过第3层的路由器来完成的。只有3层及以上的交换机才能构建虚拟局域网。与传统的局域网技术相比较，VLAN技术更加灵活，它具有以下优点： 网络设备的移动、添加和修改的管理开销减少；可以控制广播活动；可提高网络的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-概述</title>
    <link href="/2021/03/01/it/network1/"/>
    <url>/2021/03/01/it/network1/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话解释网络是什么"><a href="#一句话解释网络是什么" class="headerlink" title="一句话解释网络是什么"></a>一句话解释网络是什么</h2><p>利用通信设备和线路，将分布在不同地理位置上的具有独立功能的多台计算机、终端及其附属设备在物理上互联，按照网络协议相互通信，以共享硬件、软件和数据资源为目标的系统。</p><h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>第一个网络：ARPANET（Internet的前身），1969年美国<br>我国第一次接入网络：1994年</p><h3 id="网络发展的阶段"><a href="#网络发展的阶段" class="headerlink" title="网络发展的阶段"></a>网络发展的阶段</h3><h4 id="面向终端的计算机网络（20世纪60年代中期以前）"><a href="#面向终端的计算机网络（20世纪60年代中期以前）" class="headerlink" title="面向终端的计算机网络（20世纪60年代中期以前）"></a>面向终端的计算机网络（20世纪60年代中期以前）</h4><p>单计算机联机系统：当时主机昂贵，线路便宜。为了共享主机的资源，进行信息的采集和综合处理而产生。<br>双计算机联机系统：主计算机负责数据处理，另一台负责通信控制，从而使主计算机摆脱通信负担。<br>增加集中器：节省了通信费用，提高线路的利用率。</p><h4 id="处理机互联-amp-主机互联（20世纪60年代中期以后）"><a href="#处理机互联-amp-主机互联（20世纪60年代中期以后）" class="headerlink" title="处理机互联 &amp; 主机互联（20世纪60年代中期以后）"></a>处理机互联 &amp; 主机互联（20世纪60年代中期以后）</h4><p>主机直接相连：主机既承担数据处理工作，又承担通信工作<br>通过通信控制处理机（CCP）间接把各主计算机连接：CCP相连组成了通信子网，主机相连组成了资源子网</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><h3 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h3><p>结构上，由负责数据处理的计算机与终端、负责数据通信的CCP与通信线路组成。<br>物理上，由硬件、软件、协议组成。<br>逻辑上，计算机网络是通信技术和计算机技术的结合，包含资源子网和通信子网。<br>资源子网负责全网的数据处理，并向用户提供各种网络资源和网络服务。由各种软件和信息资源组成，包含主机、终端、终端控制器、连网外设。<br>通信子网由通信控制处理机、通信线路和其他通信设备组成，完成数据传输、转发等通信处理任务。</p><h3 id="网络的功能"><a href="#网络的功能" class="headerlink" title="网络的功能"></a>网络的功能</h3><p>1、数据通信：是计算机网络最基本的功能，主要完成网络中各节点间的系统通信。如：E-mail、FTP传文件、网上聊天<br>2、资源共享：可以实现硬件、软件资源共享。如：打印机共享、数据库共享<br>3、易于进行分布式处理：通过算法将任务交给不同计算机，协作完成。如：办公自动化、卫星发射<br>4、负载均衡：能够进行智能判断，将新任务交给空闲计算机处理<br>5、提高系统可靠性</p><h3 id="网络的分类"><a href="#网络的分类" class="headerlink" title="网络的分类"></a>网络的分类</h3><h4 id="按网络覆盖范围分类"><a href="#按网络覆盖范围分类" class="headerlink" title="按网络覆盖范围分类"></a>按网络覆盖范围分类</h4><p>广域网（WAN）：多个城市、国家，几十到几千甚至上万，跨国跨州<br>城域网（MAN）：在一个城市范围内建立，几十公里甚至数百公里<br>局域网（LAN）：文件管理、打印机共享、电子邮件等，学校、实验室、大楼<br>个人区域网：无线个人区域网，10m以内</p><h4 id="按网络传输技术划分"><a href="#按网络传输技术划分" class="headerlink" title="按网络传输技术划分"></a>按网络传输技术划分</h4><p>广播式网络：所有连网计算机共享一个公共通信信道。如：无线网、总线网<br>点对点式网络：每条物理线路连接一对计算机。如：星型、环型</p><h4 id="按网络使用范围"><a href="#按网络使用范围" class="headerlink" title="按网络使用范围"></a>按网络使用范围</h4><p>公用网：电信部门组建，政府管控。分为公共电话交换网（PSTN）、数字数据网（DDN）、综合业务数字网（ISDN）<br>专用网：某部门组建，内部使用。如：军队、铁路、电力</p><h4 id="按传输介质划分"><a href="#按传输介质划分" class="headerlink" title="按传输介质划分"></a>按传输介质划分</h4><p>有线网：双绞线、同轴电缆、光纤等<br>无线网：使用电磁波作为传输介质的计算机网络，可以传送无线电波和卫星信号</p><h4 id="按拓扑结构划分"><a href="#按拓扑结构划分" class="headerlink" title="按拓扑结构划分"></a>按拓扑结构划分</h4><p>1、总线型拓扑结构是指网络中的各个节点设备均挂接在一根总线上，实现计算机网络的功能。优点是结构简单、使用电缆少、安装方便、扩展方便；缺点是双向传输、实时性差、总线上任何一点故障都会整个瘫痪。常用在局域网。<br>2、星型拓扑结构是指网络中各节点以星型方式连接成网，网络有中央节点，其他节点（工作站、服务器）都与中央节点直接相连。优点是易于增加新站点、易于实现数据安全性和优先级的控制、易于实现网络监控；缺点是集中控制、对中心节点依赖大、线路利用率不高、信息容量浪费较大。常用在实验室、机房。<br>3、环型拓扑结构是指网络中的各节点通过环路接口连在一条首尾相连的闭合型通信线路中。优点是结构简单、传输延时确定；缺点是环中节点出现故障全体瘫痪、节点加入和退出以及环路的维护和管理复杂。<br>4、树型拓扑结构是指像一颗倒置的树，顶端是树根，树根以下带分支，每个分支还可以再带子分支，树根接收各站点发送的数据，然后再广播发到全网。优点（与星型相比）是节省线路、成本低、易扩展；缺点是对高层节点和链路要求高。适用于分级控制，如：公务员<br>5、网状型拓扑结构是指网络中各个节点通过传输线连接起来，每一个节点至少与其他两个节点相连。优点是任意两个节点间的通信无需路由，且有专线相连，没有等待延迟，所以通信速度快、可靠性高；缺点是结构复杂、投资巨大。<br>6、混合型拓扑结构。如：星型&#x2F;总线型拓扑结构，用一条&#x2F;多条总线把多组设备连接起来，相连的每组设备本身呈星型分布。</p>]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成-原理</title>
    <link href="/2021/02/01/it/composition2/"/>
    <url>/2021/02/01/it/composition2/</url>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>计算机是由硬件系统和软件系统组成的。</p><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>即实体部分，是指计算机系统中由电子、机械、光电原件组成的各种物理装置的总称。物理装置按系统结构要求构成一个有机整体，为软件运行提供物质基础。由运算器、控制器、存储器、输入设备和输出设备五个部分组成。</p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>是指计算机所需的各种程序以及有关资料。分成系统软件和应用软件。系统软件是指面向系统，用于管理整个计算机系统，合理分配系统资源，确保计算机正常高效的运行。应用软件是指面向用户，根据用户的特殊要求编制的应用程序，通常实现用户的某类要求。</p><h4 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h4><p>1、操作系统：处理机管理、文件管理、作业管理、设备管理、存储管理<br>2、语言处理程序：计算机能识别并执行的信息符号代码的指令集合称为计算机语言。<br>（1）机器语言：计算机发展初期使用的语言，采用二级制编码，能被CPU直接识别并执行，用它编写的程序运行速度快、节省内存空间、但不易读懂、不易修改。<br>（2）汇编语言：用人们熟悉的英文助记符和十进制数代替二进制编码，属于低级语言，必须通过汇编程序把汇编语言翻译成机器语言，计算机才能执行。<br>（3）高级语言：接近自然语言，包括面向过程的语言和面向对象的语言，与机器结构无关，通用性强，接近人们的自然语言和数学语言，易学易懂易调试。<br>解释语言是高级语言翻译程序的一种，它将源程序作为输入，解释一句话后就提交计算机执行下一句，并不形成目标程序。编译指的是把高级程序设计语言书写的源程序，翻译成等价的计算机汇编语言或机器语言书写的目标程序的翻译程序。<br>3、服务性程序：开发调试工具、编译程序、诊断程序<br>4、数据库：MySQL、SQLServer、Oracle、Access等</p><h4 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h4><p>通用软件、专用软件（针对企业某一具体需求研发）</p><h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><p>1、计算机由运算器、控制器、存储器、输入和输出设备五大部分组成<br>2、计算机内部采用二进制表示数据和指令<br>3、程序存储和程序控制：将数据和程序一起放在存储器中，计算机在工作时，无需人工干预，但能自动逐条取出指令并加以执行</p><h3 id="五大部件概述"><a href="#五大部件概述" class="headerlink" title="五大部件概述"></a>五大部件概述</h3><p>1、运算器：执行所有算数和逻辑运算的指令。<br>2、控制器：实现计算机各个部分的联系，并自动执行程序的部件。<br>3、存储器：是计算机的记忆部件，存储程序和数据。<br>4、输入设备：接收用户输入的原始数据和程序，并将他们转换为二进制形式存放在内存中。<br>5、输出设备：将存放在内存中由计算机处理的结果转换为人们能识别的形式和设备，由输出装置和输出接口电路组成。</p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p>运算器和控制器合称为CPU，微处理器。</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>取指令、分析指令、执行指令、控制程序和数据的输入与结果输出、对异常情况和某些请求的处理。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>把指令逐条从存储器中取出，经译码分析后向整机发出取数、执行、存数等控制命令，以保证正确完成程序所要求的功能。</p><h4 id="控制器中的寄存器"><a href="#控制器中的寄存器" class="headerlink" title="控制器中的寄存器"></a>控制器中的寄存器</h4><p>1、程序计数器（PC）：指令地址寄存器，存放当前正在执行或下一条执行的指令地址<br>2、指令寄存器（IR）：存放当前正在执行的指令<br>3、存储器数据寄存器（MDR）：存放准备存入或最近取出存储器的数据<br>4、存储器地址寄存器（MAR）：存放被访问的存储单元的地址<br>5、状态标识寄存器（PSW）：保留各种条件代码、溢出标志、进位标志等</p><h4 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h4><p>指令分操作码和地址码<br>1、首先是取指令和分析指令。按照程序规定的次序，从内存储器取出当前执行的指令。<br>2、送到控制器的指令寄存器中，对所取的指令进行分析，即根据指令中的操作码确定计算机要进行的操作。<br>3、根据指令分析结果，由控制器发出完成操作所需要的一系列的控制电位，以便指挥计算机有关的部件完成一系列操作。<br>4、为下一条取指令做准备。</p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器的性能体现在存储容量、单位成本、存储速度上，三者存在反比关系，为了解决各项性能之间的矛盾，采用多级存储器结构。主要体现在缓存-主存和主存-辅存上，缓存-主存层次主要解决的问题是CPU和主存速度不匹配的问题，主存-辅存层次主要解决存储系统的容量问题。</p><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><p>1、按照是否直接与CPU交换信息分为：<br>（1）主存：随机存储器（RAM）：SRAM和DRAM；只读存储器（ROM）：MROM、PROM、EPROM、EEPROM<br>主存就是内存，与CPU直接交换信息，速度快，容量小，存放正在运行的程序和数据<br>（2）闪速存储器（Flash Memory）：如：固态硬盘SSD<br>（3）辅存：磁盘、磁带、光盘、硬盘、移动存储设备（U盘，移动硬盘）<br>不与CPU直接交换信息，速度慢<br>（4）缓存（Cache）：用来在内存和CPU间做数据缓冲的桥梁，由SRAM组成。</p><h4 id="高速缓冲存储器cache"><a href="#高速缓冲存储器cache" class="headerlink" title="高速缓冲存储器cache"></a>高速缓冲存储器cache</h4><p>为了缓和CPU和内存之前运算速度不匹配的问题，存在于主存和CPU之间的一级存储器，容量比较小但速度比主存高，接近于CPU的速度。</p><h4 id="机械硬盘和固态硬盘"><a href="#机械硬盘和固态硬盘" class="headerlink" title="机械硬盘和固态硬盘"></a>机械硬盘和固态硬盘</h4><p>（1）机械硬盘是一种磁介质的外部存储设备，固态硬盘用固态电子存储芯片阵列而成，由控制单元和存储单元（Flash、芯片、DRAM等）组成。（2）与机械硬盘相比，固态硬盘的优点是读写速度快、防震抗摔能力强、低功耗、无噪音工作温度范围大、体积小、携带轻便。固态硬盘的缺点是容量比机械硬盘小，寿命比机械硬盘短，制造成本高，所以价格比机械硬盘贵。</p><h4 id="RAM和ROM"><a href="#RAM和ROM" class="headerlink" title="RAM和ROM"></a>RAM和ROM</h4><p>RAM（随机存储器）：存储器中的每个单元的内容可随时读出和写入，且对任一存储单元进行读写操作所需要的时间是一样的，关机后RAM的信息消失。<br>ROM（只读存储器）：一旦存入信息，在程序执行过程中，只能读出其中的信息，不能随意写入信息，关机后信息不消失。</p><h4 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h4><p>1、位（bit）：表示一个二进制数码0或1，是计算机中最小的信息单位，记为（b）<br>2、字节（Byte）：1个字节由8位组成，是衡量存储器大小的基本单位，记为（B）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1TB = 2的10次方GB = 2的20次方MB = 2的30次方KB = 2的40次方B</span><br></pre></td></tr></table></figure><p>3、字（Word）：计算机进行数据处理时，一次存储、处理和传送的数据称为字。一个字包含一个或者若干个字节。字长是计算机一次能够处理数据的实际位数，决定了计算机数据处理的速度，是衡量计算机性能的重要指标。</p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>1、片内总线：芯片内的总线<br>2、系统总线：连接CPU、主存、I&#x2F;O接口各部件之间的信息传输线，分为以下三种：<br>（1）数据总线：在CPU和RAM之间来回传送需要处理或者存储的数据<br>（2）地址总线：用来传送在RAM中存储数据的地址<br>（3）控制总线：将微处理器控制单元的信号传送到周边设备<br>3、通信总线：连接计算机系统之间或计算机与其他系统之间的信息传输线</p><h2 id="数据的表示和计算"><a href="#数据的表示和计算" class="headerlink" title="数据的表示和计算"></a>数据的表示和计算</h2><h3 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h3><p>二进制B、八进制O、十进制D、十六进制H</p><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>BCD即以二进制编码的十进制</p><h3 id="字符和字符串编码"><a href="#字符和字符串编码" class="headerlink" title="字符和字符串编码"></a>字符和字符串编码</h3><p>常见的有ASCII码、EBCDIC码</p><h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3>]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成-概述</title>
    <link href="/2021/01/01/it/composition1/"/>
    <url>/2021/01/01/it/composition1/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话解释计算机是什么"><a href="#一句话解释计算机是什么" class="headerlink" title="一句话解释计算机是什么"></a>一句话解释计算机是什么</h2><p>高度自动化的电子设备，所谓高度自动化，即接收信息、存储信息、加工处理信息、输出结果</p><h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>第一台计算机：ENIAC，1946年美国<br>第一台按存储程序控制功能设计的计算机：EDVAC，1946-1950年美国<br>第一台投入运行的按存储程序控制功能设计的计算机：EDSAC，1946-1949年美国<br>我国第一台：103机，1958年</p><h3 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h3><p>按照电子元器件（逻辑器件）的不同：<br>第一阶段：1946-1957，电子管计算机<br>第二阶段：1958-1964，晶体管计算机<br>第三阶段：1965-1972，中小规模集成电路<br>第四阶段：1972至今，大规模和超大规模集成电路（芯片）</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><h3 id="计算机的特点"><a href="#计算机的特点" class="headerlink" title="计算机的特点"></a>计算机的特点</h3><p>计算速度快、存储容量大、计算精度高、逻辑判断准确、自动化程度高、通用性强、网络与通信能力强<br>（快大高准&amp;自动&amp;通用&amp;网信）</p><h3 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h3><p>按用途：通用和专用（专用结构简单）<br>按规模和性能：巨大中小微（工作站、服务器）<br>按原理：数字、模拟、数模混合</p><h3 id="计算机的应用"><a href="#计算机的应用" class="headerlink" title="计算机的应用"></a>计算机的应用</h3><p>1、科学计算（数值计算）：最早的应用是弹道计算<br>2、数据处理（信息处理）：80%以上计算机主要用于数据处理<br>3、过程控制（实时控制）：机械、冶金、石油<br>4、辅助技术（计算机辅助设计与制造）：CAD-计算机辅助设计，CAM-计算机辅助制造，CAI-计算机辅助教学，CAE-计算机辅助工程<br>5、人工智能（AI）：翻译、模式识别<br>6、计算机网络应用</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>未来的发展趋势：巨微网智（巨型化、微型化、网络化、智能化）</p>]]></content>
    
    
    <categories>
      
      <category>IT栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>node高频</title>
    <link href="/2020/10/20/tool/node%E9%AB%98%E9%A2%91/"/>
    <url>/2020/10/20/tool/node%E9%AB%98%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<h2 id="nvm包管理"><a href="#nvm包管理" class="headerlink" title="nvm包管理"></a>nvm包管理</h2><p>nvm ls 列出所有安装的版本<br>nvm use 切换使用指定的版本node<br>nvm install 安装指定版本<br>nvm uninstall 删除已安装的指定版本<br>nvm reinstall-packages 在当前版本node环境下，重新全局安装指定版本号的npm包</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TS(ing)</title>
    <link href="/2020/06/20/fe/ts/"/>
    <url>/2020/06/20/fe/ts/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>前端栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mac常用命令</title>
    <link href="/2020/02/01/tool/command/"/>
    <url>/2020/02/01/tool/command/</url>
    
    <content type="html"><![CDATA[<p>文件相关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">新建目录：<span class="hljs-built_in">mkdir</span> xxx<br>新建文件：<span class="hljs-built_in">touch</span> xxx<br>删除文件：<span class="hljs-built_in">rm</span> xxx   <br>删除目录：<span class="hljs-built_in">rm</span> -r xxx  <br>打开文件：vim XXX<br>退出文件：:q<br>编辑文件：i<br>退出编辑模式：esc<br>保存退出：:wq<br>行标：:<span class="hljs-built_in">set</span> number<br></code></pre></td></tr></table></figure><p>查询网络端口占用：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -an <span class="hljs-string">| grep 端口号</span><br><br></code></pre></td></tr></table></figure><p>进程相关：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tcl">查看进程占用<br><br>lsof -i tcp:<span class="hljs-number">8080</span><br><br>该命令会显示占用<span class="hljs-number">8080</span>端口的进程，有其 <span class="hljs-keyword">pid</span> ,可以通过<span class="hljs-keyword">pid</span>关掉该进程<br><br>杀死进程<br><br>kill <span class="hljs-keyword">pid</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">查看host：<br>vim <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>nginx：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">重载nginx配置：<br>sudo nginx -s <span class="hljs-keyword">reload</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Storybook</title>
    <link href="/2019/12/16/festudy/first-storybook/"/>
    <url>/2019/12/16/festudy/first-storybook/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近要做一个UI组件库，提供给写java的同事们。考虑到他们的使用体验，组件的各个状态都需配置一个可视化的Demo，和一个说明文档。类似于elementUI的帮助文档:<a href="https://element.eleme.cn/#/zh-CN/component/date-picker">https://element.eleme.cn/#/zh-CN/component/date-picker</a><br>但是单独开发这样一个帮助文档，加之后期维护过于耗费人力，最好还是在开发组件的同时，把这些配套工作做了，于是找到了Storybook，一个独立的搭组件的开源工具。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>官方文档：<a href="https://storybook.js.org/">https://storybook.js.org</a></p><p>源码：<a href="https://github.com/storybookjs/storybook">https://github.com/storybookjs/storybook</a></p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>Storybook是UI组件可视化的开发运行工具，可以脱离对项目的依赖，独立运行。<br>可以构建Storybook的静态版本，并将其部署到HTTP服务器。<br>Storybook提供了可自定义的API，支持插件。<br>所以，使用Storybook，不仅可以直接往自己的项目里丢UI组件，还可以在QA和review环节回顾这些case，甚至自定义可视化页面，把UI组件分享给UI和产品。</p><h2 id="安装-amp-调试"><a href="#安装-amp-调试" class="headerlink" title="安装 &amp; 调试"></a>安装 &amp; 调试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd my-project-directory</span><br><span class="line">npx -p @storybook/cli sb init</span><br><span class="line"></span><br><span class="line">npm run storybook</span><br></pre></td></tr></table></figure><h2 id="构建一个可视化的组件-x3D-写故事"><a href="#构建一个可视化的组件-x3D-写故事" class="headerlink" title="构建一个可视化的组件 &#x3D; 写故事"></a>构建一个可视化的组件 &#x3D; 写故事</h2><p>一个组件对应一本故事书，一个状态就是一个故事。</p><h3 id="文件路径-Story-file-location"><a href="#文件路径-Story-file-location" class="headerlink" title="文件路径-Story file location"></a>文件路径-Story file location</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">•</span><br><span class="line">└── src</span><br><span class="line">    └── components</span><br><span class="line">        └── button</span><br><span class="line">            ├── button.js</span><br><span class="line">            └── button.stories.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一个简单的stories文件-Basic-story"><a href="#一个简单的stories文件-Basic-story" class="headerlink" title="一个简单的stories文件-Basic story"></a>一个简单的stories文件-Basic story</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; action &#125; from &#x27;@storybook/addon-actions&#x27;;</span><br><span class="line">import Button from &#x27;./Button&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  component: Button,</span><br><span class="line">  title: &#x27;Button&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const text = () =&gt; &lt;Button onClick=&#123;action(&#x27;clicked&#x27;)&#125;&gt;Hello Button&lt;/Button&gt;;</span><br><span class="line"></span><br><span class="line">export const emoji = () =&gt; (</span><br><span class="line">  &lt;Button onClick=&#123;action(&#x27;clicked&#x27;)&#125;&gt;</span><br><span class="line">    &lt;span role=&quot;img&quot; aria-label=&quot;so cool&quot;&gt;</span><br><span class="line">      😀 😎 👍 💯</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/Button&gt;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.2版本之后，官方建议以CSF的格式编写故事：<a href="https://storybook.js.org/docs/formats/component-story-format/">https://storybook.js.org/docs/formats/component-story-format/</a></p><h3 id="stories文件如何被编译-Loading-stories"><a href="#stories文件如何被编译-Loading-stories" class="headerlink" title="stories文件如何被编译-Loading stories"></a>stories文件如何被编译-Loading stories</h3><p>故事的加载定义在这个文件里：.storybook&#x2F;config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; configure &#125; from &#x27;@storybook/react&#x27;;</span><br><span class="line"></span><br><span class="line">configure(require.context(&#x27;../src/components&#x27;, true, /\.stories\.js$/), module);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心是configure函数，它接收三种类型的参数，详见官方文档。</p><h3 id="编写公用的样式、变量-Decorators"><a href="#编写公用的样式、变量-Decorators" class="headerlink" title="编写公用的样式、变量-Decorators"></a>编写公用的样式、变量-Decorators</h3><p>可以写在.storybook&#x2F;config.js，作用于所有的故事书，也就是所有的组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; configure, addDecorator &#125; from &#x27;@storybook/react&#x27;;</span><br><span class="line"></span><br><span class="line">addDecorator(storyFn =&gt; &lt;div style=&#123;&#123; textAlign: &#x27;center&#x27; &#125;&#125;&gt;&#123;storyFn()&#125;&lt;/div&gt;);</span><br><span class="line"></span><br><span class="line">configure(require.context(&#x27;../src/components&#x27;, true, /\.stories\.js$/), module);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以写在一个故事书里，作用于所有故事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import MyComponent from &#x27;./MyComponent&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  title: &#x27;MyComponent&#x27;,</span><br><span class="line">  decorators: [storyFn =&gt; &lt;div style=&#123;&#123; backgroundColor: &#x27;yellow&#x27; &#125;&#125;&gt;&#123;storyFn()&#125;&lt;/div&gt;],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const normal = () =&gt; &lt;MyComponent /&gt;;</span><br><span class="line">export const special = () =&gt; &lt;MyComponent text=&quot;The Boss&quot; /&gt;;</span><br><span class="line">special.story = &#123;</span><br><span class="line">  decorators: [storyFn =&gt; &lt;div style=&#123;&#123; border: &#x27;5px solid red&#x27; &#125;&#125;&gt;&#123;storyFn()&#125;&lt;/div&gt;],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编写说明-Parameters"><a href="#编写说明-Parameters" class="headerlink" title="编写说明-Parameters"></a>编写说明-Parameters</h3><p>可以编写各个作用域的说明，不再一一举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import MyComponent from &#x27;./MyComponent&#x27;;</span><br><span class="line">import componentNotes from &#x27;./notes.md&#x27;;</span><br><span class="line">import specialNotes from &#x27;./special.md&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  title: &#x27;MyComponent&#x27;,</span><br><span class="line">  parameters: &#123; notes: componentNotes &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const small = () =&gt; &lt;MyComponent text=&quot;small&quot; /&gt;;</span><br><span class="line">export const medium = () =&gt; &lt;MyComponent text=&quot;medium&quot; /&gt;;</span><br><span class="line">export const special = () =&gt; &lt;MyComponent text=&quot;The Boss&quot; /&gt;;</span><br><span class="line">special.story = &#123;</span><br><span class="line">  parameters: &#123; notes: specialNotes &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="搜索组件-Searching"><a href="#搜索组件-Searching" class="headerlink" title="搜索组件-Searching"></a>搜索组件-Searching</h3><p>可视化的页面左上角提供组件搜索框，按name和parameters.notes搜索组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export const callout = () =&gt; &lt;Callout&gt;Some children&lt;/Callout&gt;;</span><br><span class="line">callout.story = &#123;</span><br><span class="line">  parameters: &#123; notes: &#x27;popover tooltip&#x27; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Story-hierarchy-amp-Generating-nesting-path-based-on-dirname-amp-Run-multiple-storybooks"><a href="#Story-hierarchy-amp-Generating-nesting-path-based-on-dirname-amp-Run-multiple-storybooks" class="headerlink" title="Story hierarchy &amp; Generating nesting path based on __dirname &amp; Run multiple storybooks"></a>Story hierarchy &amp; Generating nesting path based on __dirname &amp; Run multiple storybooks</h3><p>当有多个书架、书架有多层时，如何设置分层、如何发布多个书架均可通过这三方参数配置</p><h2 id="如何部署项目"><a href="#如何部署项目" class="headerlink" title="如何部署项目"></a>如何部署项目</h2><p>storybook提供了将代码打包成一个静态web项目的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build-storybook&quot;: &quot;build-storybook -c .storybook -o .out&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build-storybook</span><br></pre></td></tr></table></figure><h2 id="优秀案例"><a href="#优秀案例" class="headerlink" title="优秀案例"></a>优秀案例</h2><p>官网给的案例列表：<br><a href="https://storybook.js.org/docs/basics/live-examples/">https://storybook.js.org/docs/basics/live-examples/</a><br>其中vue的url：<br><a href="https://storybookjs.now.sh/vue-kitchen-sink/?path=/story/addon-actions--action-only">https://storybookjs.now.sh/vue-kitchen-sink/?path=/story/addon-actions--action-only</a></p><p>之后会继续调研storybook的常用插件，比如如何展示源码，进一步丰富用户体验。</p>]]></content>
    
    
    <categories>
      
      <category>前端求索</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-ES6（脚本ing）</title>
    <link href="/2018/06/15/fe/jses6/"/>
    <url>/2018/06/15/fe/jses6/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2>]]></content>
    
    
    <categories>
      
      <category>前端栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>东京和京都</title>
    <link href="/2018/05/18/life/travelJp/"/>
    <url>/2018/05/18/life/travelJp/</url>
    
    <content type="html"><![CDATA[<h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><p>5月是我们走进婚姻殿堂的日子，因为是我们之间的第一个周年，暗暗的想过得有仪式感一些，而使平淡无奇的日子变得意味隽永。世界那么大，我们的选择很多，但性价比最高的东南亚5月已进入梅雨季节，欧美澳的价位又不适合我们日子刚刚起步的小夫妻，犹豫再三选择了日本，一个让中国人思虑万千的国度。<br>第一次来日本，也是第一次出国旅行，一场9天8夜的自由行出乎意料的圆满。这些天的情绪变化很奇妙，有深入鬼子心脏的刺激感，有语言不通的无力感，有背叛民族恩怨的负罪感，但这些情绪都在踏入另一种文明的兴奋感中迅速消失，直到回国之后才被再次燃起。<br>5月5日中午，飞机落地大阪关西机场。因为我们的飞机关西进关西出，所以下飞机后会直接坐新干线到东京。从机场的工作人员到jrpass的兑换人员，到新干线服务人员，所有的女性都化着精致的妆容，言辞专业，语调温柔。这份精致与专业和天津航空的工作人员形成了鲜明的对比。到东京时已是傍晚，我们第一次用GoogleMap，导航了很久才走出jr站换乘到市内地铁线（jr通票也可用）。品川位于东京港区，算是东京的富人区了。看着巨大的人流中，每个人对自己的形象都很用心，或别着精致的发卡，或带着园沿小帽子，或打着发胶定型头发。看到这些，常年头发分叉的我有一点点的自卑。大抵这也算是首都的气场和形象吧，同样也有人跟我说过初到北京的印象也是如此，或许是太熟悉北京，我不曾感受到那份惊艳，但北京一定也是有的。<br>除了惊艳于小姐姐们的温柔，和所有人用心的自我形象，还有安静、秩序、整洁。电梯上所有人都是靠左站的，留出右侧一条通道给着急的人通行，所有的路口车都会停下来让行人先过，几乎所有的厕所都有化妆台、母婴台。说起厕所也不得不赞叹日本确实电器行业发达，几乎所有的公共厕所都是自动马桶，自动水管、自动洗手液、自动送风机，有时候这三个会组合在一个洗手池子里。我住的民宿的热水壶是2008年出厂的，用了十年之久了，依然没毛病。<br>这些天的交通工具基本就是地铁，因为手持jrpass，主要乘坐山手线、中央线和总武线。几乎没有花钱坐过地铁。地铁里的文化也是很有趣的，之前听说过国人在日本地铁里吃东西而遭受到日本人的批评和白眼，我们头几次坐地铁的时候很谨慎，手机也会调静音。但次数多了也觉得不过如此，除了不能吃东西，跟北京和天津的地铁没什么差别。八点到九点之间是日本的早高峰，地铁间隔五六分钟就会来一趟，但是每次来的都是站满人的车厢，不挤根本上不去车，比起北京的早高峰有过之而无不及。晚上乘地铁的话，车厢里是满满的酒气，日本男人下班常常会喝几波酒再回家，家里的女人们也鼓励他们如此，以便和同事们搞好关系。作为中国的女人，这样的文化，我是一种求同存异、敬而远之的态度。白天乘坐地铁的时候，会看到超级多的老人，也不仅感叹日本社会老龄化的严重。<br>最后说一下日本人的服务，服务很好，尤其是试鞋的时候店员是跪着给试的，这一点我并不赞赏。所有的服务人员都很卖力，卖力的微笑，像是整个社会都进修过微笑课程是的。思哥说日本是一个笑面虎的民族，打仗从不宣战，只是偷袭。<br>与这个民族、这种文化短短9天的罩面思绪很多，但也有不准确的地方，留待以后慢慢的感悟吧。下面说一下路线和景点。<br>东京5天5夜路线：<br>day1：天津－大阪关西机场－东京<br>day2：晴空塔－浅草寺－台场<br>day3：下雨天发呆、购物<br>day4：东京铁塔－涩谷－明治神宫－新宿－东京铁塔<br>day5：迪士尼<br>day6：富士山<br>京都：<br>day7：伏见稻荷大社－清水寺－三年二坂－祁园－河源町－鸭川<br>day8：岚山<br>day9：京都－大阪关西机场－天津</p><h2 id="东京5天5夜"><a href="#东京5天5夜" class="headerlink" title="东京5天5夜"></a>东京5天5夜</h2><h3 id="天空树-浅草寺-东京铁塔-明治神宫-台场"><a href="#天空树-浅草寺-东京铁塔-明治神宫-台场" class="headerlink" title="天空树-浅草寺-东京铁塔-明治神宫-台场"></a>天空树-浅草寺-东京铁塔-明治神宫-台场</h3><p>天空树又叫新东京铁塔，也叫面包树，很像一颗耸入天际的树，天空树下是充满创意的门店、咖啡店、面包店等等。店外露天处挂着鲤鱼旗，很有日本的风味。因为天气不是很好，没有登上天空树俯视这座城市的美景。<br><img src="/assets/life/travel-jp/%E5%A4%A9%E7%A9%BA%E6%A0%91.jpeg" alt="地图"><br>比起中国的寺庙，对于日本的寺庙我也不懂得他们的文化，实在提不起兴趣。<br><img src="/assets/life/travel-jp/%E6%B5%85%E8%8D%89%E5%AF%BA.jpeg" alt="地图"><br>这几个景点中最让我意外的是东京铁塔，原以为老牌景点的风采会被天空树这样的新明星代替，然而现实并非如此。东京铁塔有两层观景台，矮一层的观景台150米，一直都接待游客，高一层的是今年年初刚刚修好的，250米，据说天晴的时候可以看到富士山。250米的特别瞭望台是环形的，中间是凹凹凸凸的镜子，对着镜子自拍便能拍到身后的夜景。从150米升到250米有一个预备电梯间，壁纸是设计师的书房，墙上挂着两幅人物肖像画，这不是两幅普通的画，他们是两幅可以动的电子画，这两幅肖像会发生对话，再现东京铁塔创造伊始的灵感，仿佛两位伟人（没记住名字）能预见今天的场景一样，很奇妙。个人感觉，只有进入暮色，东京铁塔亮起橘黄色的灯光时，才是这座塔最有魅力的时刻。<br><img src="/assets/life/travel-jp/%E4%B8%9C%E4%BA%AC%E9%93%81%E5%A1%94.jpeg" alt="地图"><br>思哥说日本从明治时代开始富有起来的，当初1840年西方侵华没有敲开中国的大门，与此同时侵日却敲开了日本的大门，割地赔款后日本派考察团赴西方学习他们的法律、交通、文化等等，然后对本国进行了大刀阔斧的改革。这是历史上有名的明治维新。为了鼓励民众参与到改革中，特地从西方引进一批红酒，现在那些红酒箱就供奉在明治神宫中供后人瞻仰。可能这就是现实版的，鸡蛋如果自己打开就是新生，如果被外界打开只能沦落成食物。生于忧患死于安乐，我们要时常警醒自己勇于改变。<br><img src="/assets/life/travel-jp/%E6%98%8E%E6%B2%BB%E7%A5%9E%E5%AE%AB.jpeg" alt="地图"><br>台场是欧美人的地盘，随处可见大个子白皮肤的人，还有一个日本的妈妈带着混血的baby，个人觉得日本人非常哈欧美人。<br><img src="/assets/life/travel-jp/%E5%8F%B0%E5%9C%BA.jpeg" alt="地图"></p><h3 id="银座-新宿-涩谷"><a href="#银座-新宿-涩谷" class="headerlink" title="银座-新宿-涩谷"></a>银座-新宿-涩谷</h3><p>都是商业区，也是购物路线。涩谷的街道比较有特点，乱乱的。<br><img src="/assets/life/travel-jp/%E9%93%B6%E5%BA%A7.jpeg" alt="地图"><br><img src="/assets/life/travel-jp/%E6%B6%A9%E8%B0%B7.jpeg" alt="地图"></p><h3 id="河口湖观富士山"><a href="#河口湖观富士山" class="headerlink" title="河口湖观富士山"></a>河口湖观富士山</h3><p><img src="/assets/life/travel-jp/%E5%AF%8C%E5%A3%AB%E5%B1%B1.jpeg" alt="地图"><br>1.关于交通：因为手持7日jrpass票，所以选择乘坐jr到大月站（可寄存行李），到大月站之后站内购买到河口湖（终点站）的火车票，是托马斯的小火车。离终点站还有两三站的时候就可以看到富士山了，车停的时候可以下车拍照。<br>2.观山地点：河口湖相邻的5个湖均可以看到富士山，以及山在水中的倒影，从托马斯的小火车上下来出站后有卖环河口湖巴士的车票，也可以选择租赁自行车环湖。因为我们计划从河口湖当天往返，所以不能环湖，我们出了车站步行15分钟到天山脚下，坐缆车到天山观景台欣赏富士山。<br>3.看到富士山的概率：据说一定是晴天才能看到雪顶富士山，冬天看到的概率比春秋天大一些，夏天的时候雪顶会消失，没有雪顶的富士山黑漆漆的一片，完全没有看头。富士山是一座活火山，山顶的火山口常常会凝结一片云，云朵大的时候会完全挡住富士山的雪顶，趁八九点太阳刚出来的时候好好欣赏富士山吧，因为过了十点钟富士山很有可能被云雾藏起来。</p><h3 id="玩透迪士尼"><a href="#玩透迪士尼" class="headerlink" title="玩透迪士尼"></a>玩透迪士尼</h3><p><img src="/assets/life/travel-jp/%E8%BF%AA%E5%A3%AB%E5%B0%BC.jpeg" alt="地图"><br>1.关于玩项目的排队时间：周三，小雨转多云的天气，中午11点半左右入场，人不多，主要是日本的学生和带小孩的家长，最长排队时间20分钟，平均排队时间小于10分钟。玩到晚上八点半放完烟花，基本可以玩的透透的。<br>2.关于快速票：有fp标志的项目可在该设施附近取票（扫门票上的二维码），每个设施fp票限量供应，发完为止，间隔两小时可以拿一次fp<br>3.关于交通：京叶线和武藏线运行在一条铁轨上，地上有指示牌，看清楚哪趟车再上<br>4.关于项目趣味性：<br>探险乐园：丛林巡航（有趣），加勒比海盗（是影迷，非常想去，但我去的时候检修），西部沿河铁路（挺没劲的）<br>西部乐园：巨雷山（略刺激），马克吐温（没劲），顽童汤姆之岛巨木筏（还可以）<br>动物天地：飞溅山（过山车类，看起来还可以，玩了巨雷山没有玩儿）<br>明日乐园：星际旅行（是影迷，有趣，略刺激），太空山（很刺激），迷藏巡游车（一般有趣）<br>梦幻乐园（大部分都是小孩子玩的）：木偶历险记（略有趣），爱丽丝（转转杯，轻微刺激），旋转木马（没劲），幽灵公馆（排队较长，直接放弃），小熊维尼（没劲）<br>卡通城（都是小孩子，一个也没玩）</p><h2 id="京都2天3夜"><a href="#京都2天3夜" class="headerlink" title="京都2天3夜"></a>京都2天3夜</h2><h3 id="伏见稻荷大社-清水寺"><a href="#伏见稻荷大社-清水寺" class="headerlink" title="伏见稻荷大社-清水寺"></a>伏见稻荷大社-清水寺</h3><p>伏见稻荷大社很有特点，红红的鸟居从上脚下一直绵延到山顶，值得一去。清水寺算是京都寺庙的代表作吧。<br><img src="/assets/life/travel-jp/%E4%BC%8F%E8%A7%81.jpeg" alt="地图"><br><img src="/assets/life/travel-jp/%E6%B8%85%E6%B0%B4.jpeg" alt="地图"></p><h3 id="三年二坂-鸭川-河源町-祁园"><a href="#三年二坂-鸭川-河源町-祁园" class="headerlink" title="三年二坂-鸭川-河源町-祁园"></a>三年二坂-鸭川-河源町-祁园</h3><p>三年二坂很像丽江，鸭川的生态保护的很好，几乎没有人工的痕迹，河面上拉着细细的线据说是为了防止天空中的飞鸟吃掉河里的鸭子。河源町的灯笼非常多，夜晚映在鸭川中很养眼。祁园是有艺妓表演的地方，各家的门口都站着一排着黑色西装扎高马尾的妹子，会让人联想到黑帮。<br><img src="/assets/life/travel-jp/%E4%BA%AC%E9%83%BD%E5%8F%A4%E5%9F%8E%E5%8C%BA.jpeg" alt="地图"></p><h3 id="岚山"><a href="#岚山" class="headerlink" title="岚山"></a>岚山</h3><p>这样的景点在中国一抓一大把，在日本应该非常少有。那份干净，与非常日式的配色，依然惊艳到了我。<br><img src="/assets/life/travel-jp/%E5%B2%9A%E5%B1%B11.jpeg" alt="地图"><br><img src="/assets/life/travel-jp/%E5%B2%9A%E5%B1%B12.jpeg" alt="地图"></p><h2 id="前期攻略"><a href="#前期攻略" class="headerlink" title="前期攻略"></a>前期攻略</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本文景点罗列较多，拟计划从本文中筛选60%进行观光。</p><h3 id="行政区划"><a href="#行政区划" class="headerlink" title="行政区划"></a>行政区划</h3><p>日本的地方行政区划制度，随明治政府于1871年实施的废藩置县政策而建立，一般分为都、道、府、县（广域地方公共团体）以及市、町、村（基础地方公共团体）两级。现今日本全国分为47个一级行政区：一都（东京都）、一道（北海道）、二府（大阪府、京都府）、四十三县，其下再设立市、町、村。地图中所圈中地点均在本次自由行考虑范围。<br><img src="/assets/life/travel-jp/%E5%85%A8%E5%9B%BD%E5%9C%B0%E5%9B%BE.jpeg" alt="地图"></p><h3 id="jr新干线"><a href="#jr新干线" class="headerlink" title="jr新干线"></a>jr新干线</h3><p><img src="/assets/life/travel-jp/%E6%96%B0%E5%B9%B2%E7%BA%BF.png" alt="地图"><br>新大阪-东京：东海道新干线-三洋新干线<br><a href="https://timetable.ekitan.com/shinkansen">https://timetable.ekitan.com/shinkansen</a></p><h3 id="东京jr"><a href="#东京jr" class="headerlink" title="东京jr"></a>东京jr</h3><p>jr是高铁的概念，市内主要乘地铁，如果持有jr pass的话，市内乘坐jr可参考以下路线。一般jr站和地铁站不是一个站。</p><h4 id="山手线"><a href="#山手线" class="headerlink" title="山手线"></a>山手线</h4><p>JR山手線環繞東京市中心運行，環城一周大約1小時。山手線車次很多，運行間隔為2～6分鐘。連接東京．上野．池袋．新宿．澀谷．品川．浜松町．新橋．有樂町（銀座）．丸之內（東京）等樞紐站，十分方便。山手線有內環和外環之分，由東京車站經品川開往澀谷方向（順時針方向轉）為外環線，由東京經上野開往池袋方向（逆時針方向轉）的為內環線。</p><p>主要車站：澀谷・新宿・池袋・上野・東京・品川</p><p>最低票價：140日圓（大人）</p><p>運行時間：首班5：00 末班24：30<br><img src="/assets/life/travel-jp/%E5%B1%B1%E6%89%8B%E7%BA%BF.png" alt="地图"></p><h4 id="中央线"><a href="#中央线" class="headerlink" title="中央线"></a>中央线</h4><p><img src="/assets/life/travel-jp/%E4%B8%AD%E5%A4%AE%E7%BA%BF.png" alt="地图"><br>以下简单分析中央线的问题</p><p>A.<br>JR中央线快速(橘色)<br>班次分为特快班次(其中又细分三种：青梅、中央、通勤)　与　快速班次<br>三鶯站至御茶之水站这一段区间<br>还会包括代表色为黄色的JR中央总武线各停(或称各站皆停、缓行)班次<br>因为这一段的路线是JR中央线跟JR总武线的铁轨路线重叠</p><p>另外吉祥寺站至中野站这一段区间<br>也有Tokyo Metro东西线使用直通运转於JR中央线区间<br>颜色为水蓝色<br>在中野站会跟中央线快速、中央总武各站皆停分流出不同路线</p><p>PS:</p><p>所以在JR吉祥寺站会有以下</p><p>橘色：JR中央线快速(包含特快或快速)<br>黄色：JR中央总武线(各站皆停、各停、缓行)<br>水蓝色：Tokyo Metro东西线　(过中野站后就不是走JR中央线的路线了)</p><p>三种月台，各月台中还会有同线路但会有多种车次停靠</p><p>再来<br>到御茶之水站，此车站就是 中央线快速(橘色) 与 中央总武线各站皆停(黄色)<br>此两种路线的分歧点<br>橘色的中央线快速过了此站后会开往神田跟终点站-东京车站<br>黄色的总武线过了此站会往秋叶原　两国　浅草桥等站<br>更之后的路线是会往千叶县的总武本线继续行驶<br>(但是每天的清晨首班跟凌晨末班车，会有两种不同车次但互相直通运转的特殊班次出现，<br>不过一般观光客很少会搭到，故不介绍！)</p><p>最后还有一种总武线快速<br>是从东京车站为起点，而且也是分歧点 (往下为直通运转横须贺线)<br>东京车站往千叶方向称总武线快速车次<br>(此段还有跟NEX、成田线直通运转<br>所以东京车站的总武线快速的月台跟NEX几乎可说是相同的)<br>东京车站往下的横滨方向还会直接直通运转横须贺线<br>不过这总武线快速你应该不会搭到<br>所以这边就不详细说明</p><p>B.<br>要去迪士尼<br>请到东京车站换搭”JR京叶线”</p><p>中央线　总武线　山手线这三种都”没有”停靠舞滨！</p><p>C.<br>中央线快速<br>中央总武线各站皆停<br>山手线</p><p>每条线路的月台都不一样<br>只是这些线路都是属於JR东日本<br>最简单就是看指标或颜色区分</p><p>D.<br>如果是搭乘中央线的各种特快班次<br>大部分的车次都是停靠三鶯站(吉祥寺站的下一站)，所以比较再往反方向折返一站<br>但是如果只是搭乘中央线快速班次<br>大部分的车次就都有停课吉祥寺站<br>可直接直达<br>或者可利用中央总武各站皆停(往三鶯方向班次)<br>或从Tokyo Metro东西线中选搭乘直通运转中央线的班次<br>也都可以直接到吉祥寺站下车<br>只是这两个方法乘车时间较长，速度较慢</p><h2 id="京都"><a href="#京都" class="headerlink" title="京都"></a>京都</h2><p>京都市是一个位于日本西部近畿地方京都府南部的城市，为京都府府厅所在地，也是政令指定都市之一。京都市的面积为827.83平方公里，下辖11个区。2017年10月，京都市有人口1,472,027人，是日本人口第八多的都市。京都市还和京都府南部、滋贺县西部及大阪府的部分地区共同组成了“京都都市圈”，其人口数约有379万。京都市也是“京阪神都会区”的一部分。<br>自794年桓武天皇迁都平安京到1868年明治天皇东京奠都为止，京都一直都是日本的首都。长年的历史积淀使得京都市拥有相当丰富的历史遗迹，也是日本传统文化的重镇之一。京都的一些传统民俗，诸如葵祭、祇园祭等已举办超过千年，成为京都独有的风景。京都市的部分历史建筑在1994年以“古都京都的文化财”的名义被列为世界文化遗产。</p><h3 id="岚山线（0-5-1日）"><a href="#岚山线（0-5-1日）" class="headerlink" title="岚山线（0.5-1日）"></a>岚山线（0.5-1日）</h3><p>“岚山”这地名原本是专指位于桂川右岸、属于京都市西京区一部分的岚山地区，而河对岸、属于右京区的地区则名为嵯峨野，但近年来许多观光导览资料都概括性地，将以横跨桂川的渡月桥为中心之河左右两岸周边地区，合称为岚山。岚山一带散布着许多知名的寺院、神社。游玩路线岚山一带可观光的景点较多，范围也比较大，需要花上半天到一天的时间来游览。抵达岚山后，你可以先从Torokko嵯峨站乘坐嵯峨野浪漫小火车至Torokko龟冈站，饱览沿途动人的景色，然后再坐小火车返回至Torokko岚山站（起点的前一站）下车，接着顺道步行去游览嵯峨野竹林、天龙寺等较为集中的景点，一路往南到标志性的渡月桥及岚山公园（中之岛地区）等地。若你时间比较充裕，在坐完单程小火车后还可以考虑从龟冈玩漂流或乘游船回到渡月桥，也可以在岚山车站附近租一辆自行车去嵯峨以北转转。当然，你也可以先游览岚山的寺庙、神社，把小火车观光作为当日行程的最后部分，再直接坐JR等轨道交通返回京都市区。标志性景观——渡月桥横跨桂川的渡月桥是岚山的标志性景观，保留着木造结构的桥身与背后树木繁茂的群山构成一幅美不胜收的山水画卷。<br><img src="/assets/life/travel-jp/%E5%B2%9A%E5%B1%B1%E7%BA%BF.png" alt="地图"></p><h4 id="嵯峨野观光小火车（有情趣的小火车）"><a href="#嵯峨野观光小火车（有情趣的小火车）" class="headerlink" title="嵯峨野观光小火车（有情趣的小火车）"></a>嵯峨野观光小火车（有情趣的小火车）</h4><p><img src="/assets/life/travel-jp/%E7%81%AB%E8%BD%A6%E8%B7%AF%E7%BA%BF.png" alt="地图"><br>官网：<a href="https://www.sagano-kanko.co.jp/sc/index.php">https://www.sagano-kanko.co.jp/sc/index.php</a><br>嵯峨野游览小火车是由小火车嵯峨站出发至小火车龟冈站,沿着风景优美的保津川溪谷缓缓行驶。单程约25分钟。春天看樱花,夏天看新绿,秋天看枫叶,冬天偶而会化为银白世界。不同季节来搭乘小火车,都可以欣赏到四季不同的美景。小火车嵯峨站紧邻JR嵯峨野线的嵯峨岚山站,距离JR京都站仅约15分钟,交通非常便利,此外,小火车嵯峨站内还有展示模型火车的立体模型京都JAPAN馆和可以租借游览嵯峨野和岚山地区方常便利的自行车的出租自行车店。</p><p>单程票价：620円<br>休息日：星期三(若遇日本国定假日时，则照常行驶)，春假、黄金周、暑假、红叶期间每天行驶，不休息。<br>售票：搭乘当日的前一个月早上１０点开始,可向JR西日本各主要车站的绿色售票口(发音为Midori-no-madoguchi)或日本国内的各大旅行社购买小火车预售票。当日车票销售开始时间：小火车嵯峨站 上午8时35分，富贵号车厢(开放式车厢)车票仅限当日销售。已经先购买预售车票的旅客,请于乘车当日到小火车各站售票口换票。(但是每日售票状况不一,当日也有换不到票的可能,这点还请见谅!)<br><img src="/assets/life/travel-jp/%E7%81%AB%E8%BD%A6%E6%97%B6%E5%88%BB%E8%A1%A8.png" alt="地图"></p><h4 id="竹林（开放性景点）"><a href="#竹林（开放性景点）" class="headerlink" title="竹林（开放性景点）"></a>竹林（开放性景点）</h4><p><img src="/assets/life/travel-jp/%E7%AB%B9%E6%9E%97.png" alt="地图"><br>竹林小径长约500米，从竹林中穿过，你可以听到风吹过竹叶发出的天籁之音，这一声音也被评为日本100种最值得保留的声音之一。岚山的竹林小道是李安拍摄《卧虎藏龙》的地方 ，小道内的天龙寺更是有着非常绝妙的日式庭园美景。</p><h4 id="渡月桥（开放性景点）"><a href="#渡月桥（开放性景点）" class="headerlink" title="渡月桥（开放性景点）"></a>渡月桥（开放性景点）</h4><p><img src="/assets/life/travel-jp/%E6%B8%A1%E6%9C%88%E6%A1%A5.png" alt="地图"><br>渡月桥是岚山的地标，别名岚桥，横跨在京都岚山的大堰川上，全长155米，据说是空海的弟子道昌于日本平安时代初期的836年（日本承和三年）整修大堰川时所建。秋季时，在红叶陪衬下的渡月桥融入岚山景致，成为代表京都的明媚景色。</p><h4 id="祇王寺（次于西芳寺的苔藓）"><a href="#祇王寺（次于西芳寺的苔藓）" class="headerlink" title="祇王寺（次于西芳寺的苔藓）"></a>祇王寺（次于西芳寺的苔藓）</h4><p><img src="/assets/life/travel-jp/%E7%A5%87%E7%8E%8B%E5%AF%BA.png" alt="地图"><br>是一处绿树环绕的安静寺庙，有一个苍苔满地的园林。树木生长得相当茂盛，因此寺庙经常被浓荫覆盖。庙内有一尊大日如来佛像。其他雕像与该寺庙在日本历史和文学中的地位有关。<br>寺庙名中的祇王是一位很久以前的舞者，她爱上了平家家族强大的领袖平清盛。在他结束了这段关系时，祇王就到这个寺庙出家为尼度过了余生，随同她的有其姐姐、母亲以及另一位被平清盛抛弃的女子。大堂中供奉有几位女子和平清盛的木雕像。</p><p>地址：京都府京都市右京区嵯峨鸟居本小坂町32<br>门票：300日元<br>营业时间：9:00～17:00</p><h4 id="天龙寺（日式庭院、世界文化遗产）"><a href="#天龙寺（日式庭院、世界文化遗产）" class="headerlink" title="天龙寺（日式庭院、世界文化遗产）"></a>天龙寺（日式庭院、世界文化遗产）</h4><p><img src="/assets/life/travel-jp/%E5%A4%A9%E9%BE%99%E5%AF%BA.png" alt="地图"><br>建于1339年，为临济宗派天龙寺院派的总院，是足利尊氏将军为供养醍醐天皇而建的，在室町时代是京都五山的第一大山。天龙寺如今是岚山地区的世界文化遗产之一。庭园借龟山和岚山之景，将贵族文化的优雅和禅宗的玄妙融为一体，是国家特别历史遗迹。寺内安放有藤原時代的释迦如来坐像。天龙寺是一年四季都很有逛头的寺院，寺内的建筑繁多，包括东西向主轴线上的法堂殿、大方丈殿及曹源池庭园，轴线以南的禅堂、友云庵、龙门亭，和轴线以北的祥云阁、多宝殿、百花苑等。著名的岚山竹林位于寺院的北面，如果先走竹林小径可以从寺院的北门进入。反之，可以从渡月桥进入岚山，从寺院正门进入，参观完毕后从北门出，接着走竹林小径，参观野宫神社。</p><p>地址：<br>门票：庭園（曹源池・百花苑）：500円、諸堂（大方丈・書院・多宝殿）：300円、法堂（屋顶有条龙）：500円<br>营业时间：8時30分 ～ 17時30分<br>素斋（不建议）：月（一汁六菜）：5000円、雪（一汁五菜）：3,000円、花（一汁七菜）：7,000円</p><h3 id="西芳寺（0-5日、世界文化遗产）"><a href="#西芳寺（0-5日、世界文化遗产）" class="headerlink" title="西芳寺（0.5日、世界文化遗产）"></a>西芳寺（0.5日、世界文化遗产）</h3><p><img src="/assets/life/travel-jp/%E8%A5%BF%E8%8A%B3%E5%AF%BA.png" alt="地图"><br>开创于奈良時代，为世界文化遗产，是日本最古老的庭园之一。庭园铺满青苔，共有120余重，又名“苔寺”。心形黄金池前面有池泉回廊。湘南亭是幕府末期岩仓具视隐居的地方。参拜前需要办理申请手续，供奉3000日元。建议游客在苔藓最为美丽的梅雨时节来访。寄明信片前去预约需要预留一定的回信时间，建议提前1-2个月预约。预约时填写希望日：(希望参观的日期，观光旺季时最好多填几个日期)<br>门票：3000日元<br>用时：3h<br>别人家的攻略：<br><a href="https://www.xiaohongshu.com/discovery/item/5ab0e72ab538bf560ed3bfdd">https://www.xiaohongshu.com/discovery/item/5ab0e72ab538bf560ed3bfdd</a><br><a href="https://www.japanhoppers.com/zh_cn/kansai/kyoto/kanko/682">https://www.japanhoppers.com/zh_cn/kansai/kyoto/kanko/682</a><br><a href="https://place.alitrip.com/yidian/2016120309042306409">https://place.alitrip.com/yidian/2016120309042306409</a></p><h3 id="京都市区线（1日-1-5日）"><a href="#京都市区线（1日-1-5日）" class="headerlink" title="京都市区线（1日-1.5日）"></a>京都市区线（1日-1.5日）</h3><p><img src="/assets/life/travel-jp/%E4%BA%AC%E9%83%BD.png" alt="地图"></p><h4 id="金阁寺-x2F-鹿苑寺"><a href="#金阁寺-x2F-鹿苑寺" class="headerlink" title="金阁寺&#x2F;鹿苑寺"></a>金阁寺&#x2F;鹿苑寺</h4><p><img src="/assets/life/travel-jp/%E9%B9%BF%E8%8B%91%E5%AF%BA.png" alt="地图"><br><img src="/assets/life/travel-jp/%E9%B9%BF%E8%8B%91%E5%AF%BA%E5%86%85.png" alt="地图"><br>金阁寺本名是鹿苑寺，由于寺内核心建筑舍利殿的外墙全部贴以金箔装饰，故昵称为“金阁寺”。寺院始建于1397年，原为足利义满将军（即动画《聪明的一休》中利将军的原型）的山庄，后改为禅寺“菩提所”。据说以金阁为中心的庭园为“极乐净土”，与寺前的镜湖池相互辉映，尤其在晴天风景极好，而这也成为了京都的象征。游客扎堆的景点，想避开人满为患的话，可以选择早上开园时或下午接近闭园时前往；天气好的话早晚的景色正是金阁寺最美的时刻。金阁寺园内可走动的范围不大，但等待合影留念的游客很多，建议合理安排时间。</p><p>官网：<a href="http://www.shokoku-ji.jp/k_access.html">http://www.shokoku-ji.jp/k_access.html</a><br>地址：京都市北区金閣寺町1<br>参拜时间：午前9：00〜午後5：00<br>门票：400円</p><h4 id="清水寺-x2F-音语山（寺庙、宗教场所、世界文化遗产）"><a href="#清水寺-x2F-音语山（寺庙、宗教场所、世界文化遗产）" class="headerlink" title="清水寺&#x2F;音语山（寺庙、宗教场所、世界文化遗产）"></a>清水寺&#x2F;音语山（寺庙、宗教场所、世界文化遗产）</h4><p><img src="/assets/life/travel-jp/%E6%B8%85%E6%B0%B4%E5%AF%BA1.png" alt="地图"><br><img src="/assets/life/travel-jp/%E6%B8%85%E6%B0%B4%E5%AF%BA2.png" alt="地图"><br>清水寺是一座位于日本京都府京都市东山区清水的寺院，于778年前后由延镇上人起造。清水寺的山号为音羽山，主要供奉千手观音，原本属于法相宗这一宗派但目前已独立，成为北法相宗的大本山。 清水寺与北山鹿苑寺、岚山天龙寺等同为京都境内最著名的名胜古迹，一年四季前来朝拜的香客或来访的观光客是络驿不绝。游玩清水寺，除寺庙本身外还有一个乐趣就是在山下的小路漫步。这里的三年坂·二年坂以及附近的清水坂都是历史保护街区，沿路有各种餐饮店、土特产店，热闹非凡。八坂神社离清水寺很近，很多人是先游玩八坂神社再一路散步去清水寺，步程约1.5公里。</p><p>官网：<a href="http://www.kiyomizudera.or.jp/">http://www.kiyomizudera.or.jp/</a><br>地址：京都市東山区清水一丁目294<br>门票：官网不详，其他攻略指出600円<br>营业时间：不详</p><h4 id="伏见稻荷大社（历史建筑-建筑人文）"><a href="#伏见稻荷大社（历史建筑-建筑人文）" class="headerlink" title="伏见稻荷大社（历史建筑 建筑人文）"></a>伏见稻荷大社（历史建筑 建筑人文）</h4><p><img src="/assets/life/travel-jp/%E4%BC%8F%E8%A7%81%E7%A8%BB%E8%8D%B7.png" alt="地图"><br>伏见稻荷大社是京都古老的神社之一，而“千鸟居”是这座神社较有名的景观了。稻荷神社的鸟居的颜色是统一的红色，如果某些企业效益很好，会向神社敬献一座鸟居，因此稻荷神社的鸟居和其他神社不同，经常在门前排有一列鸟居，有大有小。较为壮观的是伏见稻荷大社，几千座鸟居分成几排，从山脚一直排列到山顶。</p><p>官网：<a href="http://inari.jp/zh-cn/faq/">http://inari.jp/zh-cn/faq/</a><br>地址：京都市伏見区深草薮之内町68番地<br>门票：官网不详，其他攻略指出免费<br>营业时间：不详</p><h4 id="三年坂二年坂类（特色街区、建筑人文、开放性景点）"><a href="#三年坂二年坂类（特色街区、建筑人文、开放性景点）" class="headerlink" title="三年坂二年坂类（特色街区、建筑人文、开放性景点）"></a>三年坂二年坂类（特色街区、建筑人文、开放性景点）</h4><p>日本的京都清水寺附近的清水坂、二年坂和产宁坂是三条历史保护街区。二年坂和三年坂都是小小的石头坡道，偶尔有阶梯，二年坂据称于大同2年(807)建造完成，共有17级三年坂建造于大同3年(808)，连结清水坂与二年坂。由于这段坡道是通往祈求平安生产的子安塔(泰产寺)的参道，再加上日文读法中的生产平安“产宁”和“三年”发音接近，因此三年坂也被称为产宁坂。产宁坂石阶共有46级，两旁房舍多半是江户时期的町屋木造房子，沿途商家多半贩卖清水烧、京都特产古风瓷品店以及古意盎然的饮食店和纪念品店。</p><h4 id="祇园（特色街区、建筑人文、开放性景点）"><a href="#祇园（特色街区、建筑人文、开放性景点）" class="headerlink" title="祇园（特色街区、建筑人文、开放性景点）"></a>祇园（特色街区、建筑人文、开放性景点）</h4><p>是京都的艺伎区，也是京都代表性的地区。白天，附近有7世纪的餐馆和茶馆可供消遣，路上也可以看到行色匆匆的艺伎与你擦间而过。而到了傍晚这个地方才真正生动起来，灯笼微明，灯光在纸窗后柔和地闪动，你可以见到实习期间的艺伎正匆忙地工作。</p><h4 id="花见小路（仅国内叫法，特色街区、建筑人文、开放性景点）"><a href="#花见小路（仅国内叫法，特色街区、建筑人文、开放性景点）" class="headerlink" title="花见小路（仅国内叫法，特色街区、建筑人文、开放性景点）"></a>花见小路（仅国内叫法，特色街区、建筑人文、开放性景点）</h4><p>花见小路是位于老茶馆万亭（也叫一力亭）西侧的一条南北走向的街道。而老茶馆万亭（也叫一力亭）位于四条大街向西走100米的地方。涂有华丽红壳漆的墙壁和由竹子编织而成的栅栏的一力亭的附近，并排着的都是挡有垂帘的茶屋，街道环境清幽、规划整齐。</p><h4 id="鸭川（开放性景点）"><a href="#鸭川（开放性景点）" class="headerlink" title="鸭川（开放性景点）"></a>鸭川（开放性景点）</h4><p><img src="/assets/life/travel-jp/%E9%B8%AD%E5%B7%9D.png" alt="地图"><br>鸭川是日本京都的一个景点，也是代表京都的一条长31公里的一级河川。这条河流的水十分清澈，流穿过京都中央。从古代起居民已经住在河流的两旁，特别是西岸及南岸。</p><h4 id="瑠璃光院"><a href="#瑠璃光院" class="headerlink" title="瑠璃光院"></a>瑠璃光院</h4><p><img src="/assets/life/travel-jp/%E7%91%A0%E7%92%83%E5%85%89%E9%99%A2.png" alt="地图"><br>是历代皇族、住持经常访问的地方。日式屋廊与五彩枫叶完美结合，层林尽染斑斓意，说是日本最美的赏枫之处也不为过。别处的红叶只有红黄两色，这里却有粉色，登上楼台三色交映，看得人如在幻境之中。开放时间有限制，待查明。</p><p>官网：<a href="http://rurikoin.komyoji.com/">http://rurikoin.komyoji.com</a><br>期間：4月15日（日）～6月15日(金）<br>拝観時間：10：00～17：00<br>拝観料：一般2,000円</p><h4 id="贵船神社"><a href="#贵船神社" class="headerlink" title="贵船神社"></a>贵船神社</h4><p><img src="/assets/life/travel-jp/%E8%B4%B5%E8%88%B9%E7%A5%9E%E7%A4%BE.png" alt="地图"><br>从平安京迁都的时候开始作为掌管水之神受到崇拜。神社因为丑时来参拜神社的女性多而知名，传说和泉式部也在这里祈祷过。</p><p>官网：<a href="http://kifunejinja.jp/">http://kifunejinja.jp</a><br>地址：京都市左京区鞍馬貴船町180<br>时间：6：00～20：00 （5月1日～11月30日）<br>门票：官网未显示，其他攻略指出免费</p><h4 id="二条城"><a href="#二条城" class="headerlink" title="二条城"></a>二条城</h4><p><img src="/assets/life/travel-jp/%E4%BA%8C%E6%9D%A1%E5%9F%8E.png" alt="地图"><br>二条城是一座位于日本京都府京都市中京区二条城町的城堡，建设于江户时代初期。曾经是德川家康的寓所。位于京都市街的一座平城。1994年，被联合国教育科学文化组织列入世界遗产中的古都京都的文化财之一。</p><p>官网：<a href="http://www2.city.kyoto.lg.jp/bunshi/nijojo">http://www2.city.kyoto.lg.jp/bunshi/nijojo</a><br>时间：8:45 am - 4pm（下午5点关闭）<br>门票：600円</p><h4 id="平安神宫"><a href="#平安神宫" class="headerlink" title="平安神宫"></a>平安神宫</h4><p><img src="/assets/life/travel-jp/%E5%B9%B3%E5%AE%89%E7%A5%9E%E5%AE%AB.png" alt="地图"><br>平安神宫，位于京都府京都市左京区的神社。旧社格为官币大社、敕祭社。现在是神社本厅的别表神社。平安神宫是为了纪念京都成为首都1100周年而于1895年建成的神社。大鸟居、大极殿、炫目的朱红色神苑都是平安神宫的标志性建筑。此外，神苑是明治时期极具代表性的日式庭园，共分为东、中、西、南四大部分，这里四季鲜花盛放，吸引着游人们来访。</p><p>官网：<a href="http://www.heianjingu.or.jp/">http://www.heianjingu.or.jp/</a><br>地址：京都市左京区岡崎西天王町97<br>时间：8:30～17:30<br>门票：600円</p><h4 id="八坂神社"><a href="#八坂神社" class="headerlink" title="八坂神社"></a>八坂神社</h4><p>日本全国约有3000多座八坂神社，而位于京都祇园的是八坂神社的总本社，也被称为祇园神社，是京都香火最旺的神社之一。这里每年7月都会举行热闹非凡的祇园祭，与东京的神田祭、大阪的天神祭并称为“日本三大祭”。神社入口八坂神社有好几个入口，如果你从四条通前往，过了东大路通便是神社的西楼门，朱红的色调十分亮眼。若是绕到南楼门外，还会看到一座巨大的石造鸟居。进门后可以先到旁边的“手水舍”去入乡随俗洗个手。舞殿来到神社中央的本殿前，有一座舞殿，是举行祭祀的舞台。你会注意到舞殿的四周都挂满了提灯，上面写着不同赞助商的名称，保佑他们生意兴隆。每当夜幕降临，这些提灯会被点亮，将舞殿点缀得特别华美。黄昏时欣赏落日要是正好在黄昏前来到八坂神社，你不仅能欣赏到落日余晖洒在朱漆大门上的美景，等到天黑后，还能感受灯光映照下宁静而耀眼的别样氛围。</p><p>门票：官网不详，其他攻略指出免费<br>营业时间：9:00-16:30</p><h4 id="贺茂御祖神社"><a href="#贺茂御祖神社" class="headerlink" title="贺茂御祖神社"></a>贺茂御祖神社</h4><p>贺茂御祖神社为一位于京都市左京区的神社，通称下鸭神社。为二十二社之一、式内社、山城国一宫、旧社格为官币大社。主祭神为玉依姬命与贺茂建角身命。例祭日为5月15日。现任宫司为新木直人。 贺茂御祖神社是联合国科教文组织 所登记的世界文化遗产之一，是遗产项目古都京都的文化财的其中一部分。</p><p>官网：<a href="http://www.shimogamo-jinja.or.jp/">http://www.shimogamo-jinja.or.jp</a></p><h4 id="三十三间堂"><a href="#三十三间堂" class="headerlink" title="三十三间堂"></a>三十三间堂</h4><p>也叫莲华王院，其南北向达120米的主殿是日本最长的木造建筑之一，因正殿由33根立柱隔开而得名。殿内供奉着被列为日本国宝级的佛像和文物，尤其以1001尊千手观音像而闻名。来到三十三间堂，建筑的外观简洁朴素，但内部的景象却十分震撼。入内参观需要脱鞋，而且不能拍照。</p><h4 id="京都塔"><a href="#京都塔" class="headerlink" title="京都塔"></a>京都塔</h4><p>矗立在京都站前的京都塔建于1964年，高131米，是京都最高的建筑。采用灯塔造型的外观看起来有点像日式蜡烛，十分醒目，晚上还会发出柔和的灯光，照亮京都的夜空。</p><p>京都写完，其他待续。。。</p><h2 id="东京"><a href="#东京" class="headerlink" title="东京"></a>东京</h2><p>东京都是位于日本关东地方的地方行政区，与道、府、县同属日本第一级行政区划，为事实上的日本首都。辖区包含东京都区部、多摩地方、伊豆群岛、小笠原群岛等地区，同时也囊括了日本最南端和最东端等几个地理极点。面积约2,188平方公里，人口1,374万，人口总数居于日本各都道府县首位。全境划分为23区、26市、5町、8村，其中都厅所在地为新宿区。<br>截至2017年止，东京都是GDP产值世界第1的都市，超过世界第二纽约的1.5倍。东京都2010年的人均总生产额达到6,955,171日元，位列全世界第一。以东京都为核心的日本首都圈，聚集人口逾3千6百万，为世界第一大都会区。</p><h3 id="市内（2-3d）"><a href="#市内（2-3d）" class="headerlink" title="市内（2-3d）"></a>市内（2-3d）</h3><p><img src="/assets/life/travel-jp/%E4%B8%9C%E4%BA%AC%E7%BB%8F%E5%85%B8%E6%A6%82%E5%86%B5.png" alt="地图"></p><h4 id="晴空塔-x2F-東京スカイツリー"><a href="#晴空塔-x2F-東京スカイツリー" class="headerlink" title="晴空塔&#x2F;東京スカイツリー"></a>晴空塔&#x2F;東京スカイツリー</h4><p>东京晴空塔，又译称东京天空树、新东京铁塔，是位于日本东京都墨田区的电波塔，由东武铁道及其子公司东武塔晴空塔共同筹建，于2008年7月14日动工，2012年2月29日完工、同年5月22日正式启用。<br><img src="/assets/life/travel-jp/%E6%99%B4%E7%A9%BA%E5%A1%94%E7%A5%A8.png" alt="地图"></p><h3 id="迪士尼（1-2d）"><a href="#迪士尼（1-2d）" class="headerlink" title="迪士尼（1-2d）"></a>迪士尼（1-2d）</h3><p><a href="http://www.tokyodisneyresort.jp/">http://www.tokyodisneyresort.jp</a></p>]]></content>
    
    
    <categories>
      
      <category>旅行</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node-Express</title>
    <link href="/2018/04/04/festudy/express-middleware/"/>
    <url>/2018/04/04/festudy/express-middleware/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Express是基于Node.js的Web开发框架。<br>官网：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn</a><br>优点：线性逻辑，通过中间件形式把业务逻辑细分、简化，一个请求进来经过一系列中间件处理后再响应给用户，清晰明了。<br>缺点：基于 callback 组合业务逻辑，业务逻辑复杂时嵌套过多，异常捕获困难。</p><h2 id="常见第三方中间件："><a href="#常见第三方中间件：" class="headerlink" title="常见第三方中间件："></a>常见第三方中间件：</h2><h3 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h3><p>是HTTP请求体解析中间件，解析成功后覆盖原来的req.body，如果解析失败则为{}。官网：<a href="https://github.com/expressjs/body-parser">https://github.com/expressjs/body-parser</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 解析自定义的 JSON</span><br><span class="line">app.use(bodyParser.json(&#123; type: &#x27;application/*+json&#x27; &#125;))</span><br><span class="line"></span><br><span class="line">// 解析自定义的 Buffer</span><br><span class="line">app.use(bodyParser.raw(&#123; type: &#x27;application/vnd.custom-type&#x27; &#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="multer"><a href="#multer" class="headerlink" title="multer"></a>multer</h3><p>是处理multipart&#x2F;form-data类型表单数据的中间件，它主要用于上传文件。官网：<a href="https://github.com/expressjs/multer">https://github.com/expressjs/multer</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;)</span><br><span class="line">var app = express()</span><br><span class="line">var multer  = require(&#x27;multer&#x27;)</span><br><span class="line">var upload = multer()</span><br><span class="line"></span><br><span class="line">app.post(&#x27;/profile&#x27;, upload.array(), function (req, res, next) &#123;</span><br><span class="line">  // req.body 包含文本域</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="cookie-parser"><a href="#cookie-parser" class="headerlink" title="cookie-parser"></a>cookie-parser</h3><p>是解析cookie的中间件，cookie存储在客户端，是不可信任的，经常配合session使用。官网：<a href="https://github.com/expressjs/cookie-parser">https://github.com/expressjs/cookie-parser</a></p><h3 id="express-session"><a href="#express-session" class="headerlink" title="express-session"></a>express-session</h3><p>解析session的中间件，它的基本原理是服务端为每一个session维护一份会话信息数据，而客户端和服务端依靠一个全局唯一的标识来访问会话信息数据。用户访问web应用时，服务端程序决定何时创建session。官网：<a href="https://github.com/expressjs/session%E3%80%82%E5%85%B3%E4%BA%8Esession%E5%92%8Ccookie%E7%9A%84%E5%A5%BD%E6%96%87%EF%BC%9Ahttp://www.cnblogs.com/zhuzhenwei918/p/6778490.html">https://github.com/expressjs/session。关于session和cookie的好文：http://www.cnblogs.com/zhuzhenwei918/p/6778490.html</a></p><h3 id="express-static"><a href="#express-static" class="headerlink" title="express-static"></a>express-static</h3><p>将包含静态资源的目录的名称传递给 express.static 中间件函数，以便开始直接提供这些文件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&#x27;public&#x27;));</span><br><span class="line">// 可以访问位于 public 目录中的文件：http://localhost:3000/images/kitten.jpg</span><br><span class="line">app.use(&#x27;/static&#x27;, express.static(&#x27;public&#x27;));</span><br><span class="line">// 可以访问具有 /static 路径前缀的 public 目录中的文件:http://localhost:3000/static/images/kitten.jpg</span><br></pre></td></tr></table></figure><h3 id="consolidate"><a href="#consolidate" class="headerlink" title="consolidate"></a>consolidate</h3><p>各种模板引擎的结合体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const server = require(&#x27;express&#x27;)();</span><br><span class="line">const consolidate = require(&#x27;consolidate&#x27;);</span><br><span class="line"></span><br><span class="line">// 设置把模板以html形式输出</span><br><span class="line">server.set(&#x27;view engine&#x27;,&#x27;html&#x27;);</span><br><span class="line">// 模板位置</span><br><span class="line">server.set(&#x27;views&#x27;,&#x27;./views&#x27;);</span><br><span class="line">// 使用ejs引擎去解析html，这里可以设置多种多对</span><br><span class="line">server.engine(&#x27;html&#x27;,consolidate.ejs);</span><br><span class="line"></span><br><span class="line">server.get(&#x27;/index&#x27;,function(req,res)&#123;</span><br><span class="line">    res.render(&#x27;index.html&#x27;,&#123;username:&#x27;eric&#x27;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(1337);</span><br></pre></td></tr></table></figure><h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">const express=require(&#x27;express&#x27;);</span><br><span class="line">const static=require(&#x27;express-static&#x27;);</span><br><span class="line">const cookieParser=require(&#x27;cookie-parser&#x27;);</span><br><span class="line">const cookieSession=require(&#x27;cookie-session&#x27;);</span><br><span class="line">const bodyParser=require(&#x27;body-parser&#x27;);</span><br><span class="line">const multer=require(&#x27;multer&#x27;);</span><br><span class="line">const consolidate=require(&#x27;consolidate&#x27;);</span><br><span class="line">const mysql=require(&#x27;mysql&#x27;);</span><br><span class="line"></span><br><span class="line">//连接池</span><br><span class="line">const db=mysql.createPool(&#123;host: &#x27;localhost&#x27;, user: &#x27;root&#x27;, password: &#x27;123456&#x27;, database: &#x27;blog&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">var server=express();</span><br><span class="line">server.listen(8080);</span><br><span class="line"></span><br><span class="line">//1.解析cookie</span><br><span class="line">server.use(cookieParser(&#x27;sdfasl43kjoifguokn4lkhoifo4k3&#x27;));</span><br><span class="line"></span><br><span class="line">//2.使用session</span><br><span class="line">var arr=[];</span><br><span class="line">for(var i=0;i&lt;100000;i++)&#123;</span><br><span class="line">  arr.push(&#x27;keys_&#x27;+Math.random());</span><br><span class="line">&#125;</span><br><span class="line">server.use(cookieSession(&#123;name: &#x27;zns_sess_id&#x27;, keys: arr, maxAge: 20*3600*1000&#125;));</span><br><span class="line"></span><br><span class="line">//3.post数据</span><br><span class="line">server.use(bodyParser.urlencoded(&#123;extended: false&#125;));</span><br><span class="line">server.use(multer(&#123;dest: &#x27;./www/upload&#x27;&#125;).any());</span><br><span class="line"></span><br><span class="line">//4.配置模板引擎</span><br><span class="line">//输出什么东西</span><br><span class="line">server.set(&#x27;view engine&#x27;, &#x27;html&#x27;);</span><br><span class="line">//模板文件放在哪儿</span><br><span class="line">server.set(&#x27;views&#x27;, &#x27;./template&#x27;);</span><br><span class="line">//哪种模板引擎</span><br><span class="line">server.engine(&#x27;html&#x27;, consolidate.ejs);</span><br><span class="line"></span><br><span class="line">//接收用户请求</span><br><span class="line">server.get(&#x27;/&#x27;, (req, res, next)=&gt;&#123;</span><br><span class="line">  //查询banner的东西</span><br><span class="line">  db.query(&quot;SELECT * FROM banner_table&quot;, (err, data)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      res.status(500).send(&#x27;database error&#x27;).end();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      res.banners=data;</span><br><span class="line"></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.get(&#x27;/&#x27;, (req, res, next)=&gt;&#123;</span><br><span class="line">  //查询文章列表</span><br><span class="line">  db.query(&#x27;SELECT ID,title,summery FROM article_table&#x27;, (err, data)=&gt;&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      res.status(500).send(&#x27;database error&#x27;).end();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      res.articles=data;</span><br><span class="line"></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.get(&#x27;/&#x27;, (req, res)=&gt;&#123;</span><br><span class="line">  res.render(&#x27;index.ejs&#x27;, &#123;banners: res.banners, articles: res.articles&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.get(&#x27;/article&#x27;, (req, res)=&gt;&#123;</span><br><span class="line">  res.render(&#x27;conText.ejs&#x27;, &#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4.static数据</span><br><span class="line">server.use(static(&#x27;./www&#x27;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端求索</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码阅读二</title>
    <link href="/2018/03/22/festudy/source-vue2/"/>
    <url>/2018/03/22/festudy/source-vue2/</url>
    
    <content type="html"><![CDATA[<h2 id="src-x2F-platforms-x2F-web-x2F-entry-runtime-with-compiler-js引入文件"><a href="#src-x2F-platforms-x2F-web-x2F-entry-runtime-with-compiler-js引入文件" class="headerlink" title="src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler.js引入文件"></a>src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler.js引入文件</h2><h3 id="import-query-from-‘-x2F-util-x2F-index’"><a href="#import-query-from-‘-x2F-util-x2F-index’" class="headerlink" title="import { query } from ‘.&#x2F;util&#x2F;index’"></a>import { query } from ‘.&#x2F;util&#x2F;index’</h3><p>参数：选择器或DOM元素<br>返回：DOM元素</p><h3 id="import-warn-cached-from-‘core-x2F-util-x2F-index’"><a href="#import-warn-cached-from-‘core-x2F-util-x2F-index’" class="headerlink" title="import { warn, cached } from ‘core&#x2F;util&#x2F;index’"></a>import { warn, cached } from ‘core&#x2F;util&#x2F;index’</h3><h4 id="cached-from-‘shared-x2F-util’"><a href="#cached-from-‘shared-x2F-util’" class="headerlink" title="cached from ‘shared&#x2F;util’"></a>cached from ‘shared&#x2F;util’</h4><p>cached：缓存一个新的函数，结合entry-runtime-with-compiler.js对此函数的应用，通过cached防止了重新操作&#x2F;获取DOM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export function cached&lt;F: Function&gt; (fn: F): F &#123;</span><br><span class="line">  const cache = Object.create(null)</span><br><span class="line">  return (function cachedFn (str: string) &#123;</span><br><span class="line">    const hit = cache[str]</span><br><span class="line">    return hit || (cache[str] = fn(str))</span><br><span class="line">  &#125;: any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">知识点：</span><br><span class="line">泛型就是指定一个表示类型的变量，用它来代替某个实际的类型用于编程，而后通过实际调用时传入或推导的类型来对其进行替换，</span><br><span class="line">以达到一段使用泛型程序可以实际适应不同类型的目的</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端求索</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue进阶</title>
    <link href="/2018/03/15/festudy/second-vue/"/>
    <url>/2018/03/15/festudy/second-vue/</url>
    
    <content type="html"><![CDATA[<h2 id="状态管理模式-vuex"><a href="#状态管理模式-vuex" class="headerlink" title="状态管理模式-vuex"></a>状态管理模式-vuex</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>在大型单页应用中，组件共用的字段变多，导致为组件通信写了很多代码，不仅容易疏漏，后期还不易维护，将各组件的共同依赖抽离出来集中的管理变得十分必要。</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，集中式的存储状态以及状态的变化规则，响应式的管理状态。</p><h3 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h3><p>状态集中存储在Store对象中</p><h4 id="第一步：安装Vuex"><a href="#第一步：安装Vuex" class="headerlink" title="第一步：安装Vuex"></a>第一步：安装Vuex</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><h4 id="第二步：按照项目结构要求新建store文件夹"><a href="#第二步：按照项目结构要求新建store文件夹" class="headerlink" title="第二步：按照项目结构要求新建store文件夹"></a>第二步：按照项目结构要求新建store文件夹</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── XXXX1.js       # 购物车模块</span><br><span class="line">        └── XXXX2.js   # 产品模块</span><br></pre></td></tr></table></figure><h4 id="第三步：创建Vuex实例"><a href="#第三步：创建Vuex实例" class="headerlink" title="第三步：创建Vuex实例"></a>第三步：创建Vuex实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    XXXX1,</span><br><span class="line">    XXXX2</span><br><span class="line">  &#125;,</span><br><span class="line">  strict: debug,</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中一个模块，假设是permission</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">  permissions: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getters = &#123;</span><br><span class="line">  permissions: state =&gt; state.permissions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">  updatePermissions (&#123; commit &#125;, sys) &#123;</span><br><span class="line">    permission.getPermissionForButton(sys)</span><br><span class="line">      .then((data) =&gt; &#123;</span><br><span class="line">        commit(&#x27;UPDATEPERMISSION&#x27;, data)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations = &#123;</span><br><span class="line">  &#x27;UPDATEPERMISSION&#x27; (state, permissions) &#123;</span><br><span class="line">    state.permissions = permissions</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  actions,</span><br><span class="line">  mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.js中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import store from &#x27;@/store/index&#x27;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第四步：在组件中通过计算属性返回store的状态"><a href="#第四步：在组件中通过计算属性返回store的状态" class="headerlink" title="第四步：在组件中通过计算属性返回store的状态"></a>第四步：在组件中通过计算属性返回store的状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count () &#123;</span><br><span class="line">    return this.$store.state.permissions</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>getter是对state的封装，就像对原生状态加个插件一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">        userPermissions () &#123;</span><br><span class="line">          return this.$store.getters.permissions</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><h4 id="第五步：状态管理"><a href="#第五步：状态管理" class="headerlink" title="第五步：状态管理"></a>第五步：状态管理</h4><p>触发mutation或者action中的方法均可以管理状态<br>可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）<br>Mutation 必须是同步函数，包含异步（如请求api）操作时用action，action通过返回mutation对象异步的变更状态，如何分发action、如何使用组合action在官网查看详情。<br>触发状态管理的方法较多，请参照vuex官网:<a href="https://vuex.vuejs.org/zh-cn/intro.html">https://vuex.vuejs.org/zh-cn/intro.html</a></p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h3><p>在Vue的模式下，借助双向数据绑定和内置指令，我们几乎可以完全着眼于数据的变化，而不用关注DOM本身。很少的情况下，需要操作DOM，当同一种情况反复出现时，自定义一个指令，像使用内置指令一样，声明式的操作DOM更高效些。</p><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>是程序员注册的指令，同内置指令一样，将数据的变化映射为DOM的行为。</p><h3 id="怎么办-1"><a href="#怎么办-1" class="headerlink" title="怎么办"></a>怎么办</h3><p>第一，通过directive注册在全局或局部<br>第二，通过钩子函数定义指令行为，钩子函数的参数均包含指令绑定的DOM元素、虚拟DOM元素、binding对象（指令命名、值、入参等）<br>步骤详解：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html#ad">https://cn.vuejs.org/v2/guide/custom-directive.html#ad</a></p><h2 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a>自定义组件的 v-model</h2><h3 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h3><p>表单输入组件默认触发事件为input，有时候需要checked、change、focus等事件触发组件的行为，这时就需要显示的定义触发事件类型</p><h3 id="怎么办-2"><a href="#怎么办-2" class="headerlink" title="怎么办"></a>怎么办</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-checkbox&#x27;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;checked&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: Boolean,</span><br><span class="line">    // 这样就允许拿 `value` 这个 prop 做其它事了</span><br><span class="line">    value: String</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>步骤详解：<a href="https://cn.vuejs.org/v2/guide/components.html#demo-2">https://cn.vuejs.org/v2/guide/components.html#demo-2</a></p>]]></content>
    
    
    <categories>
      
      <category>前端求索</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码阅读一</title>
    <link href="/2018/03/01/festudy/source-vue/"/>
    <url>/2018/03/01/festudy/source-vue/</url>
    
    <content type="html"><![CDATA[<p>主要阅读npm run dev和npm run build的两条主线，首先来看npm run dev的执行主线：</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>打包工具：rollup<br>npm run dev执行文件：config.js<br>知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rollup关键配置：</span><br><span class="line">•entry 源代码的入口</span><br><span class="line">•moduleName 这个参数只有设置了umd的时候才需要设置</span><br><span class="line">•plugins 顾名思义，这里是来放插件的</span><br><span class="line">•format 设置打包的模式，比如umd，cjs等</span><br><span class="line">•dest 输出</span><br><span class="line">•banner 可以在输出文件的头部写入一段你想写的</span><br><span class="line">•alias 别名</span><br><span class="line">•env 环境变量，比如process.env等</span><br><span class="line">rollup与其他工具的集成：</span><br><span class="line">rollup-plugin-buble：es6转es5</span><br><span class="line">rollup-plugin-alias：用别名缩短path</span><br><span class="line">rollup-plugin-commonjs：commonjs转es5（应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测）</span><br><span class="line">rollup-plugin-node-resolve：如何安装外部模块</span><br><span class="line">rollup-plugin-replace：可以将动态设置的变量提取出来，在配置文件中设置</span><br></pre></td></tr></table></figure><h2 id="scripts-x2F-config-js"><a href="#scripts-x2F-config-js" class="headerlink" title="scripts&#x2F;config.js"></a>scripts&#x2F;config.js</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (process.env.TARGET) &#123;</span><br><span class="line">  module.exports = genConfig(process.env.TARGET)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  exports.getBuild = genConfig</span><br><span class="line">  exports.getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>npm run dev*执行函数：genConfig(…)<br>“dev”: “rollup -w -c scripts&#x2F;config.js –environment TARGET:web-full-dev”,<br>等同于执行rollup –w –config (config变量)将entry-runtime-with-compiler.js打包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports与exports.XXXX：</span><br><span class="line">知乎来讲：require方只能看到module.exports对象，我们在编写模块时用到的exports对象实际上是对module.exports对象的引用。</span><br><span class="line">Node.js实战来讲：典型的模块是一个包含exports对象属性定义的文件，用module.exports微调模块的创建，module.exports可以对外提供单个的函数或变量，不必局限于一个对象。一个文件中既有module.exports又有exports时，exports被忽略。</span><br><span class="line">Object.assign(target, source1,…):</span><br><span class="line">Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。</span><br><span class="line">Object.defineProperty(obj,prop,descriptor):</span><br><span class="line">直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。默认情况下，使用Object.defineProperty()添加的属性值是不可变的。</span><br></pre></td></tr></table></figure><h2 id="src-x2F-platforms-x2F-web-x2F-entry-runtime-with-compiler-js"><a href="#src-x2F-platforms-x2F-web-x2F-entry-runtime-with-compiler-js" class="headerlink" title="src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler.js"></a>src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler.js</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">知识点：</span><br><span class="line">expr1 &amp;&amp; expr2:</span><br><span class="line">如果expr1 能转换成false则返回expr1，否则返回expr2。</span><br><span class="line">也就是说el=el &amp;&amp; query(el)等价于：</span><br><span class="line">if(el)&#123;el=query(el)&#125;</span><br><span class="line">document.querySelector():</span><br><span class="line">element 是一个 element 对象（DOM 元素）。</span><br><span class="line">selectors 是一个字符串，包含一个或是多个 CSS 选择器 ，多个则以逗号分隔。</span><br><span class="line">str.charAt():</span><br><span class="line">返回一个新的字符串，该字符串由位于指定偏移量处的单个UTF-16代码单元组成。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端求索</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2018/02/20/tool/git%E6%8C%87%E4%BB%A4/"/>
    <url>/2018/02/20/tool/git%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">版本回退：</span><br><span class="line">本地没有pull最新的代码，直接commit导致push的时候产生冲突：</span><br><span class="line">将修改代码粘贴出去执行：git reset --hard HEAD^回退到上一个版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES5不说再见</title>
    <link href="/2018/01/29/festudy/ES5-point/"/>
    <url>/2018/01/29/festudy/ES5-point/</url>
    
    <content type="html"><![CDATA[<h2 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h2><p>大部分语言的变量都是先声明后使用，但在es5中变量未声明时使用并不报错，因为声明提升到了执行代码前。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 1;</span><br></pre></td></tr></table></figure><p>值得注意的是函数声明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">在JavaScript中，一个变量名进入作用域的方式有 4 种：</span><br><span class="line"></span><br><span class="line">Language-defined：所有的作用域默认都会给出 this 和 arguments 两个变量名（global没有arguments）;</span><br><span class="line">Formal parameters（形参）：函数有形参，形参会添加到函数的作用域中;</span><br><span class="line">Function declarations（函数声明）：如 <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;;</span><br><span class="line">Variable declarations（变量声明）：如 var foo，包括_函数表达式_。</span><br><span class="line">函数声明和变量声明总是会被移动（即hoist）到它们所在的作用域的顶部（这对你是透明的）。</span><br><span class="line">而变量的解析顺序（优先级），与变量进入作用域的4种方式的顺序一致。</span><br><span class="line"></span><br><span class="line">一个详细的例子：</span><br><span class="line"><span class="keyword">function</span> testOrder(arg) &#123;</span><br><span class="line">    console.log(arg); // arg是形参，不会被重新定义</span><br><span class="line">    console.log(a); // 因为函数声明比变量声明优先级高，所以这里a是函数</span><br><span class="line">    var arg = <span class="string">&#x27;hello&#x27;</span>; // var arg;变量声明被忽略， arg = <span class="string">&#x27;hello&#x27;</span>被执行</span><br><span class="line">    var a = 10; // var a;被忽视; a = 10被执行，a变成number</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">a</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;fun&#x27;</span>);</span><br><span class="line">    &#125; // 被提升到作用域顶部</span><br><span class="line">    console.log(a); // 输出10</span><br><span class="line">    console.log(arg); // 输出hello</span><br><span class="line">&#125;;</span><br><span class="line">testOrder(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">/* 输出：</span><br><span class="line">hi</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;fun&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">10</span><br><span class="line">hello</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">from:https://github.com/creeperyang/blog/issues/16</span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域是指执行到当前代码时的上下文，或者说是环境。有全局作用域：声明在函数体外变量；函数作用域：声明在函数体中的变量，但凡是声明时没有var修饰的变量，均当做全局变量。<br>es5没有块级作用域，只有函数级作用域，函数外面的变量函数里面可以找到，函数里面的变量函数外面找不到。</p><h2 id="变量生存周期"><a href="#变量生存周期" class="headerlink" title="变量生存周期"></a>变量生存周期</h2><p>全局变量，生命周期是永久的。局部变量，当定义该变量的函数调用结束时，该变量就会被垃圾回收机制回收而销毁。再次调用该函数时又会重新定义了一个新变量。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>是函数和声明该函数的词法环境的组合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//父函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">superFn</span></span>()&#123;</span><br><span class="line">// 局部变量</span><br><span class="line">var _super_a = 1;</span><br><span class="line"></span><br><span class="line">var subFn = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  _super_a++;</span><br><span class="line">  alert(<span class="string">&#x27;_super_a: &#x27;</span> + _super_a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> subFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// superFn() 得到的是subFn，superFn()()等于subFn()</span><br><span class="line">superFn()();</span><br></pre></td></tr></table></figure><p>无论执行多少次superFn()()，永远输出’_super_a:2’，因为superFn()()的词法环境永远是var _super_a &#x3D; 1;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//父函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">superFn</span></span>()&#123;</span><br><span class="line">// 局部变量</span><br><span class="line">var _super_a = 1;</span><br><span class="line"></span><br><span class="line">var subFn = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  _super_a++;</span><br><span class="line">  alert(<span class="string">&#x27;_super_a: &#x27;</span> + _super_a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> subFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// superFn() 得到的是subFn，superFn()()等于subFn()</span><br><span class="line">var s = superFn();</span><br><span class="line">s()</span><br><span class="line">s()</span><br></pre></td></tr></table></figure><p>第一个s()执行输出’_super_a:2’，第二个s()执行输出’_super_a:3’，因为s()的词法环境是同一个superFn()</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">　　var name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　　　　　　　<span class="built_in">return</span> that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure><p>代码执行后输出’My Object’，因为object.getNameFunc()()的词法环境中this指向object</p><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。块级作用域可以做到，但ES5没有块级作用域的概念，所以出现了闭包。使用闭包可以在JavaScript中模拟块级作用域，可以用于在对象中创建私有变量。<br>闭包的生存周期等同于全局变量，是永久的，所以闭包使用不当会导致内存泄漏，通常手动将变量设置为null来结束闭包的生命周期。</p><h3 id="怎么办？"><a href="#怎么办？" class="headerlink" title="怎么办？"></a>怎么办？</h3><p>因为函数是JavaScript中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数，具体请看如下解释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">作者：王殊</span><br><span class="line">链接：https://www.zhihu.com/question/19554716/answer/146795877</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">要真正理解JavaScript里的闭包，就一定要脱离能看得见的js代码，看看在js引擎里，一个函数的创建和执行到底发生了什么，每一个变量名又是如何解析的。</span><br><span class="line"></span><br><span class="line">首先，每一个函数都有一个隐藏的属性[[Scope]]，这个属性保存着函数的作用域链，它本质上是一个集合，它的每个值引用一个数据的集合。</span><br><span class="line">函数中的变量名解析，实质上就是在[[Scope]]引用的每一个数据的集合里查找同名的键，如果找到了，就读取这个键对应的值，如果没有，就触发异常。</span><br><span class="line"></span><br><span class="line">当一个函数被创建的时候，如果这个函数形式上没有父函数，则[[Scope]]属性的第一个值会引用当前的全局上下文，所有全局变量及其存储的数据都在这个集合里。</span><br><span class="line">此时[[Scope]]属性如下：</span><br><span class="line">[    (Global Context)]</span><br><span class="line">当一个函数被调用的时候，会创建一个Execute context，即运行时上下文，它存储调用该函数的对象，函数的参数数组，函数的局部变量（值还未定义），该集合会被压入[[Scope]]属性，此时[[Scope]]属性如下：</span><br><span class="line">[    (Execute context),    (Global Context)]</span><br><span class="line">当一个函数返回的时候，引擎只是去除[[Scope]]属性中对运行时上下文的引用，并没有立即销毁它。此时运行时上下文没有任何引用了，符合了被销毁的条件，在将来的某个时刻会被垃圾收集器销毁。此时[[Scope]]属性如下：</span><br><span class="line">[    (Global Context)]</span><br><span class="line"></span><br><span class="line">好了，我们再看看，如果一个函数创建的时候存在父函数会是什么情形：当一个子函数被创建时，显然，这个创建是父函数的执行导致的，所以当子函数创建时，父函数已经处于执行阶段，所以父函数的执行上下文已经创建了。同时，因为子函数也在父函数的局部变量作用域内，所以，子函数在创建的时候，除了要引用全局上下文，也需要引用父函数的执行上下文，否则子函数就无法访问父函数的局部变量，违背了设计的要求。此时两个函数的[[Scope]]属性如下：</span><br><span class="line">父函数：[    (Execute context),    (Global Context)]</span><br><span class="line">子函数：[    (Execute context),//这里引用的是父函数的执行上下文，自身的执行上下文此时还未创建。</span><br><span class="line"> (Global Context)]</span><br><span class="line"> 当一个子函数执行时，因为它同样是函数，所以它同样需要创建自己的执行上下文，当它返回的时候，同样也只解除[[Scope]]属性中对自身执行上下文的引用，对父函数的执行上下文的引用并没有解除，这意味着，父函数的执行上下文与子函数本身共存亡了。所以，为什么父函数的局部变量没有被销毁？因为它们所在的执行上下文还被子函数的[[Scope]]属性引用着，只要子函数还存在引用，垃圾收集器就不会销毁它们所在的执行上下文。注意，因为父函数已经执行完毕了，所以父函数的执行上下文中的局部变量如果有赋值，那此时这些变量也已经有了相应的值。另外，因为父函数的局部变量并不在全局上下文中，所以它只能在子函数的变量解析中被访问，自然而然就相当于它们是子函数私有的了。</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>垃圾回收是一种自动的内存管理机制，浏览器将不再使用的内存清除，寻找不再使用的内存主要有两种方式：引用计数和标记清除。<br>引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。标记清除是JavaScript中最常见的垃圾回收方式。为什么说这是种最常见的方法，因为从2012年起，所有现代浏览器都使用了标记-清除的垃圾回收方法，定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。<br>内存泄漏是指计算机可用的内存越来越少，主要是因为程序不能释放那些不再使用的内存，一旦数据不再使用，最好通过将其值设为 null 来释放其引用，这个方法被称为“解除引用”，解除一个值的引用不代表垃圾回收器会立即将这段内存回收，这样做的目的是让垃圾回收器在下一个回收周期到来时知道这段内存需要回收。另外，减少内存垃圾的另一个方法就是避免创建对象。<br>详细：<a href="https://zhuanlan.zhihu.com/p/23992332%EF%BC%8C%E5%80%BC%E5%BE%97%E4%B8%80%E8%AF%BB%E3%80%82">https://zhuanlan.zhihu.com/p/23992332，值得一读。</a></p>]]></content>
    
    
    <categories>
      
      <category>前端求索</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哈尔滨</title>
    <link href="/2018/01/02/life/travelHeb/"/>
    <url>/2018/01/02/life/travelHeb/</url>
    
    <content type="html"><![CDATA[<h2 id="人文"><a href="#人文" class="headerlink" title="人文"></a>人文</h2><p>哈尔滨是冰城，名不虚传，这两天玩儿冰上活动已然很high了，论经济发达程度的话，当真是不比沿海城市。曾经的重工业区，多多少少遗留了第二次产业革命的病根儿。重重的雾霾、大把的下岗工人、还有锈迹斑斑的旧厂房。</p><h2 id="景色"><a href="#景色" class="headerlink" title="景色"></a>景色</h2><h3 id="松花江"><a href="#松花江" class="headerlink" title="松花江"></a>松花江</h3><p>看过了萧红的《呼兰河传》，印象里松花江是荒凉萧索的。走在冬季冰封千里的松花江里，不禁感叹萧红的伟大，与印象里一模一样。<br><img src="/assets/life/travel-heb/shj.jpeg" alt="哈尔滨"><br>夜晚防洪纪念碑处的江中像是浩瀚夜色里的一团火苗，叫卖的小商贩和各种散客看官人人一脸兴奋，点烟花的、放天灯的、拉雪橇的、摩托车的热热闹闹，大抵萧红书里放河灯的场景就是如此罢。人群的热闹更衬得冬夜漫漫，荒凉缥缈。<br><img src="/assets/life/travel-heb/shj2.jpeg" alt="哈尔滨"></p><h3 id="冰雪大世界"><a href="#冰雪大世界" class="headerlink" title="冰雪大世界"></a>冰雪大世界</h3><p>我原抱着欣赏冰雕的目的而来，身临其境才发现我脑子里的冰太小了，园子里没有小巧可爱的冰娃娃，而是雕栏玉砌、层楼叠榭，我反而像是一个小娃娃。<br><img src="/assets/life/travel-heb/bxsj3.jpeg" alt="哈尔滨"><br><img src="/assets/life/travel-heb/bxsj4.jpeg" alt="哈尔滨"><br><img src="/assets/life/travel-heb/bxsj1.jpeg" alt="哈尔滨"><br>除了令人赞叹的建筑外，雪橇、冰刀、马车、滑梯、样样玩得畅快，零下二十度愣是玩出了一身汗。</p><h3 id="中央大街"><a href="#中央大街" class="headerlink" title="中央大街"></a>中央大街</h3><p>中央大街算是哈尔滨的名片，但与天津的滨江道、重庆的解放碑、成都的春熙路比起来并无特色，这里就不再上照片了。</p><h3 id="苏菲亚教堂"><a href="#苏菲亚教堂" class="headerlink" title="苏菲亚教堂"></a>苏菲亚教堂</h3><p>来一张夜景图，的确是美的。<br><img src="/assets/life/travel-heb/xkjt.jpeg" alt="哈尔滨"></p><h3 id="虎林园"><a href="#虎林园" class="headerlink" title="虎林园"></a>虎林园</h3><p>东北虎是自然界里体型最大的老虎，如果说比东北虎还要大的虎，那就是狮虎兽了，公狮子与母老虎的后代，世界上一共存活着12只。此次之行只隐隐约约的看了一眼狮虎兽，总觉得它是孤独的，不仅仅是没有同伴，而是没有同类的忧伤。虎林园一共散养1200多只东北虎，按照老虎的年龄和凶狠程度分到不同的隔离区饲养。游客坐在车里隔着玻璃看老虎，别有一番紧张。据说每年6月到8月到此游玩，正赶上小老虎的出生，幸运的话还能把小虎崽抱上一抱。<br><img src="/assets/life/travel-heb/lh1.jpeg" alt="哈尔滨"><br><img src="/assets/life/travel-heb/lh2.jpeg" alt="哈尔滨"></p><h2 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h2><p>老厨家的锅包肉与我在天津吃的果然不同，格外的酥脆不腻，还很有故事。油炸冰激凌、大拉皮、酸菜、粉条炖肉都是特色，美味程度依次递减。<br><img src="/assets/life/travel-heb/gbr.jpeg" alt="哈尔滨"></p>]]></content>
    
    
    <categories>
      
      <category>旅行</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node</title>
    <link href="/2017/11/25/fe/first-node/"/>
    <url>/2017/11/25/fe/first-node/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>和Java类似的写服务端程序的语言<br>既用来写服务器端应用程序，又用来写服务器本身，换句话说，它的运行不需要任何容器，它本身就提供了实现容器的方法。<br>构建在JavaScript之上，会紧跟ES标准，也就是说可以使用JavaScript最新的特性。<br>node官方文档：<a href="http://nodejs.cn/api">http://nodejs.cn/api</a></p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为了在不增加学习成本的情况下，实现前端程序员的全栈梦<br>为实现轻量级的、分布式的、实时数据服务一类的应用提供简便的方法</p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><h3 id="提供JavaScript的运行环境"><a href="#提供JavaScript的运行环境" class="headerlink" title="提供JavaScript的运行环境"></a>提供JavaScript的运行环境</h3><p>浏览器的引擎就是现成的运行环境，浏览器厂商白热化的竞争使得引擎的性能大幅提升，而Google Chrome的V8引擎将JavaScript直接编译成本地机器码，性能极优。<br>Node首先要提供JavaScript的运行环境，也就是JavaScript运行的虚拟机，Node的作者并没有自己写这样一个虚拟机，而是借用了Chrome的V8虚拟机。</p><h3 id="如何解决I-x2F-O阻塞"><a href="#如何解决I-x2F-O阻塞" class="headerlink" title="如何解决I&#x2F;O阻塞"></a>如何解决I&#x2F;O阻塞</h3><p>Apache解决I&#x2F;O阻塞的方法是来一个请求，开一个线程的多线程服务，与Apache不同，Node只有一个线程，代码异步执行，不会产生阻塞。<br>I&#x2F;O操作在脚本执行的主顺序之外执行，当I&#x2F;O操作完成后，触发一个事件，执行回调函数。<br>这种机制使得Node服务器像nginx一样高效，可以随时相应请求，不必担心服务器被I&#x2F;O操作拖垮。</p>]]></content>
    
    
    <categories>
      
      <category>前端栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mac环境安装mysql</title>
    <link href="/2017/11/20/tool/mysql/"/>
    <url>/2017/11/20/tool/mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h2><p><a href="https://www.mysql.com/cn/downloads/">https://www.mysql.com/cn/downloads/</a></p><h2 id="找不到初始密码，重置吧"><a href="#找不到初始密码，重置吧" class="headerlink" title="找不到初始密码，重置吧"></a>找不到初始密码，重置吧</h2><p>首先要在”设置-&gt;mysql”中关闭mqsql服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入终端输入：cd /usr/local/mysql/bin/</span><br><span class="line">回车后 登录管理员权限 sudo su</span><br><span class="line">回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">回车后mysql会自动重启（偏好设置中mysql的状态会变成running</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入命令 ./mysql</span><br><span class="line">回车后，输入命令 FLUSH PRIVILEGES;</span><br><span class="line">回车后，输入命令 SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;你的新密码&#x27;);</span><br><span class="line">回车后，输入命令 flush privileges;</span><br><span class="line">回车后，输入命令 exit;</span><br><span class="line">重启mysql</span><br></pre></td></tr></table></figure><h2 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>在文件中插入PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin<br>若无此文件，新建即可<br><code>source ~/.bash_profile</code></p><h2 id="启动、重启、停止"><a href="#启动、重启、停止" class="headerlink" title="启动、重启、停止"></a>启动、重启、停止</h2><p>启动 sudo &#x2F;usr&#x2F;local&#x2F;MySQL&#x2F;support-files&#x2F;mysql.server start<br>重启 sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server restart<br>停止 sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server stop</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>香格里拉</title>
    <link href="/2017/06/01/life/travelDq/"/>
    <url>/2017/06/01/life/travelDq/</url>
    
    <content type="html"><![CDATA[<p><img src="/assets/life/travel-dq/pdc5.jpeg" alt="香格里拉"><br>看过了《冈仁波齐》，把自己的迪庆之行比作朝圣未免有辱朝圣二字，但我的确是带着一颗敬畏心而来。从丽江到迪庆有5小时的车程，我们翻山越岭而来，只盼一撇香格里拉。<br>夜幕降临的时候我们到达了迪庆县城的宾馆，放下行李，就去土司家吃藏餐了。马奶酒和青稞面吃不习惯，吃完饭看了藏族朋友们的表演，大概八点就回去休息了。<br><img src="/assets/life/travel-dq/pdc3.jpeg" alt="香格里拉"><br>第二天八点出发去石卡雪山，没有驶出县城时，可以看到路边三两行人，大都是送孩子上学的藏族女人，穿着长袖长袍、头戴艳丽头巾、腰间系着彩色围裙。开出县城后，一路上就没看到什么车和人了。大约半小时到了蓝月山谷，也就到了石卡雪山脚下，索道几乎到山顶了。《消失的地平线》中，香格里拉与外界交换东西的地方就叫蓝月山谷，这里应该是根据书里所讲后取的名字。<br>大约快到中午，从石卡雪山上下来，下一站是我最期待的普达措国家森林公园。在停车场迎接我的是三两成群的藏香猪，司机扎西说，这些小猪一贯爱抢游客手里的东西。<br><img src="/assets/life/travel-dq/pdc1.jpeg" alt="香格里拉"><br>在普达措徒步一下午，秀丽的景色喂饱了眼睛，终于不枉此行。普达措和我所在的世界完全不同，我的世界声色犬马、匆匆忙忙，在这里时间是悠长的、甚至静止的。<br><img src="/assets/life/travel-dq/pdc6.jpeg" alt="香格里拉"><br><img src="/assets/life/travel-dq/pdc2.jpeg" alt="香格里拉"><br>因为普达措和蓝月山谷遗失绝尘的美，把迪庆称作香格里拉，我心里是认同的。<br>德钦太远，没有去到飞来寺，没有看到梅里雪山，实属遗憾。</p>]]></content>
    
    
    <categories>
      
      <category>旅行</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建</title>
    <link href="/2017/05/20/tool/hexo-deploy-vultr/"/>
    <url>/2017/05/20/tool/hexo-deploy-vultr/</url>
    
    <content type="html"><![CDATA[<p>我原以为部署Hexo的静态页面很简单，上传到服务器的某个路径，用代理服务器关联路径到某个端口，就可以访问了！这样做是ok的，但是很不Hexo。<br>Hexo封装了上传动作，在_config.yml文件中配置上目标服务器，一个hexo deploy指令就将编译后的页面直接部署到服务器上了，省去了远程登录服务器、上传文件、重新部署这些操作。</p><h2 id="本地搭建Hexo"><a href="#本地搭建Hexo" class="headerlink" title="本地搭建Hexo"></a>本地搭建Hexo</h2><p><a href="https://hexo.io/">https://hexo.io/</a></p><h2 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h2><p>可以选择github作为目标服务器，在你的github上，创建一个名为：用户名.github.io的仓；修改Hexo下的_config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:用户名/用户名.github.io.git</span><br></pre></td></tr></table></figure><p>至此完成了部署到服务器的配置，每次部署执行下面的自动部署命令即可。<br>如何部署到自己的VPS上，参照这篇博客：<br><a href="https://weiyf.cn/2016/05/05/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2%E8%AF%A6%E8%A7%A3/">https://weiyf.cn/2016/05/05/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2%E8%AF%A6%E8%A7%A3/</a></p><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate --deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2(框架思想)</title>
    <link href="/2017/05/01/fe/first-vue/"/>
    <url>/2017/05/01/fe/first-vue/</url>
    
    <content type="html"><![CDATA[<p>17年年初开始接触Vue，认真学习一个月后，加入了团队重构Vue的任务中。React、Angular、Vue是这两年国内最热的话题，都是要学的，之所以最先选择Vue，除了工作中的契机还源于内心对母语的依恋。所以在这里，不仅仅是初识Vue，还是初识前端框架。在此总结下Vue的关键特性，以记录学习感悟。<br>每一个特性都围绕是什么、怎么办、为什么展开，从普遍方法讲到Vue的方法。</p><h2 id="特性一：MVVM-双向数据绑定"><a href="#特性一：MVVM-双向数据绑定" class="headerlink" title="特性一：MVVM-双向数据绑定"></a>特性一：MVVM-双向数据绑定</h2><h3 id="是什么？是一种MV-模式"><a href="#是什么？是一种MV-模式" class="headerlink" title="是什么？是一种MV*模式"></a>是什么？是一种MV*模式</h3><p>首先，从一个业务场景中体会一下什么是模式。</p><p>有这样一个场景，有个input框，用户输入内容后，验证并提示用户输入内容是否合法。</p><p>传统html+js的做法：获取input中数据——&gt;验证数据——&gt;修改页面视图</p><p>mvvm框架的做法：input中数据同步更新到内存——&gt;从内存取input数据并验证——&gt;修改内存中各组件属性，根据数据变化，视图自动更新</p><p><img src="/assets/first-vue/mvvm_abstract.png" alt="模式"></p><ul><li>M：业务逻辑相关的数据的封装载体</li><li>V：界面的显示和渲染</li><li>VM：View和Model的粘合体，负责View和Model的交互和协作</li></ul><p>如此来看MVVM模式是比没有模式多出一些操作来的，这样有什么好处吗？</p><h3 id="为什么？为了避免操作DOM，为了解耦M和V"><a href="#为什么？为了避免操作DOM，为了解耦M和V" class="headerlink" title="为什么？为了避免操作DOM，为了解耦M和V"></a>为什么？为了避免操作DOM，为了解耦M和V</h3><p>首先，Vue使用MVVM模式更彻底的封装了DOM，操作数据完全代替了操作DOM。</p><p>众所周知，对浏览器而言DOM操作是个麻烦，避免操作原生DOM也就避免了兼容性、复杂性等问题。</p><p>节约了使用事件代理、一次性生成DOM节点、在内存中操作DOM、缓存DOM对象等手动优化DOM操作。</p><p>解耦M和V的好处在于：</p><ul><li>低耦合：View可以独立于Model修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li><li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li><li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li><li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li></ul><h3 id="如何实现MVVM"><a href="#如何实现MVVM" class="headerlink" title="如何实现MVVM"></a>如何实现MVVM</h3><p>实现MVVM就是实现数据绑定加视同更新，实现方法有脏检查、数据模型、数据监听等多种，在此推荐一篇文章，细讲这些方法的不同：<a href="http://www.ayqy.net/blog/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%843%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">http://www.ayqy.net/blog/双向数据绑定的3种实现方式/</a></p><p>Vue如何实现MVVM，我找到一张这样的图片：</p><p><img src="/assets/first-vue/mvvm_vue.png" alt="Vue实现MVVM"></p><ul><li>Object.defineProperty()劫持数据，跟踪依赖。get方法：添加value到订阅者集合，set方法：监听到value变化时，通知订阅者更新视图。</li><li>使用观察者模式，数据变化时通知订阅者更新视图</li></ul><p>上一张图很好的描述了Vue如何执行MVVM，关于Vue如何初始化MVVM我画了如下流程图：</p><p><img src="/assets/first-vue/mvvm_init.png" alt="Vue初始化MVVM"></p><h2 id="特性二：Virtual-DOM-虚拟DOM"><a href="#特性二：Virtual-DOM-虚拟DOM" class="headerlink" title="特性二：Virtual DOM-虚拟DOM"></a>特性二：Virtual DOM-虚拟DOM</h2><h3 id="是什么？是用JS描述DOM的一种更新DOM的算法"><a href="#是什么？是用JS描述DOM的一种更新DOM的算法" class="headerlink" title="是什么？是用JS描述DOM的一种更新DOM的算法"></a>是什么？是用JS描述DOM的一种更新DOM的算法</h3><p>html描述DOM：<br>&lt;ul id&#x3D;”myId”&gt;&lt;li&gt;Item 1&lt;&#x2F;li&gt;&lt;li&gt;Item 2&lt;&#x2F;li&gt;&lt;ul&gt;<br>js对象描述DOM：<br>Let domNode &#x3D; {<br>  tag: “ul”<br>  attributes: { id: “myId” }<br>  children: [<br>    &#x2F;&#x2F; where the LI”s would go<br>  ]};</p><h3 id="如何实现？先用虚拟DOM缓冲、再批量操作DOM"><a href="#如何实现？先用虚拟DOM缓冲、再批量操作DOM" class="headerlink" title="如何实现？先用虚拟DOM缓冲、再批量操作DOM"></a>如何实现？先用虚拟DOM缓冲、再批量操作DOM</h3><p>实现Virtual DOM的通用方法如下：</p><ol><li>用JS对象模拟DOM树</li><li>比较两棵虚拟DOM树的差异</li><li>把差异应用到真正的DOM树上</li></ol><ul><li>如何实现Virtual DOM：<a href="https://github.com/livoras/blog/issues/13">https://github.com/livoras/blog/issues/13</a></li></ul><p>Vue是如何实现Virtual DOM的？</p><ul><li>VDOM：Vue的虚拟DOM</li><li>VNode：Virtual DOM采用的数据结构</li><li>patch.js：新旧 VNode 对比的 diff 函数，diff 算法来源于 snabbdom，snabbdom 的算法根据 DOM 操作跨层级增删节点较少的特点进行调整，将代码复杂度降到 O(n)</li></ul><p>获取template——&gt;编译template为render()，render返回当前页面VNode<br>数据更新——&gt;执行render()，返回新VNode——&gt;执行patch()，新旧 VNode 对比 diff——&gt;根据diff更新DOM</p><p>从Vue的模板渲染中看Virtual DOM的实现</p><p><img src="/assets/first-vue/virtualDOM.png" alt="Vue实现Virtual DOM"></p><h3 id="为什么要使用Virtual-DOM？为了减少回流重绘次数"><a href="#为什么要使用Virtual-DOM？为了减少回流重绘次数" class="headerlink" title="为什么要使用Virtual DOM？为了减少回流重绘次数"></a>为什么要使用Virtual DOM？为了减少回流重绘次数</h3><ul><li>操作DOM代价大，单页DOM多，代价更大</li><li>和Vue使用Virtual DOM的出发点一样，有一篇很好的文章Reatc为什么使用Virtual DOM：<a href="https://mblur.com/notes/2016/08/28/react-why-virtual-dom.html">https://mblur.com/notes/2016/08/28/react-why-virtual-dom.html</a></li><li>浏览器优化后也可批处理DOM，但对开发人员是黑盒，react将批处理的时机选择交到了我们手中，我们可以控制何时render页面。</li></ul><p>浏览器更新DOM的代价，可见下图：<br><img src="/assets/first-vue/virtualDOM_DOM.png" alt="操作DOM的代价"></p><h2 id="特点三：构建简单"><a href="#特点三：构建简单" class="headerlink" title="特点三：构建简单"></a>特点三：构建简单</h2><h3 id="如何构建一个Vue项目"><a href="#如何构建一个Vue项目" class="headerlink" title="如何构建一个Vue项目"></a>如何构建一个Vue项目</h3><p>引入Vue.js: &lt;script src&#x3D;“<a href="https://unpkg.com/vue/dist/vue.js%E2%80%9D%3E&lt;/script%3E">https://unpkg.com/vue/dist/vue.js”&gt;&lt;/script&gt;</a><br>更合适做法：用脚手架vue-cli<br>vue-cli涉及到的主要技术框架：</p><ul><li>node.js：整个脚手架工具的根本组成部分；</li><li>commander：能够更好地组织和处理命令行的输入；</li><li>download-git-repo：从git远程仓库下载文件；</li><li>handlebars：语义模板库；</li><li>metalsmith：静态页面构建，配合handlebars使用；</li></ul><p>安装步骤：</p><ul><li>安装vue-cli：npm install -g vue-cli</li><li>使用webpack模板：vue init webpack my-project</li><li>可以参考：<a href="http://www.jianshu.com/p/beae26e57b0f">http://www.jianshu.com/p/beae26e57b0f</a></li></ul><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><ul><li>index.html：访问入口</li><li>main.js：webpack部署项目的入口文件</li><li>build：打包后的文件放在这里</li><li>src：存放自己的文件</li><li>可以参考：<a href="http://www.runoob.com/vue2/vue-directory-structure.html">http://www.runoob.com/vue2/vue-directory-structure.html</a></li></ul><h3 id="WebPack"><a href="#WebPack" class="headerlink" title="WebPack"></a>WebPack</h3><p>WebPack可以看做是模块打包机：<br>它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。<br>webpack配置分析：<br><a href="https://github.com/DDFE/DDFE-blog/issues/10">https://github.com/DDFE/DDFE-blog/issues/10</a></p><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>加载模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>本地启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>启动一个express服务，挂到一个端口上，强制浏览器打开这个url，用express结合webpack全栈自动刷新，实现热替换。</p><p>生产环境启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><p>webpack将文件打包到build文件夹中，可通过ng等反向代理服务器的配置，将index.html文件的路径映射到一个url上。</p><h2 id="特点四：组件化"><a href="#特点四：组件化" class="headerlink" title="特点四：组件化"></a>特点四：组件化</h2><h3 id="组件化是什么"><a href="#组件化是什么" class="headerlink" title="组件化是什么"></a>组件化是什么</h3><p><img src="/assets/first-vue/components_web1.png" alt="Vue实现Virtual DOM"></p><p><img src="/assets/first-vue/components_web2.png" alt="Vue实现Virtual DOM"></p><h3 id="为什么要组件化"><a href="#为什么要组件化" class="headerlink" title="为什么要组件化"></a>为什么要组件化</h3><ul><li>可以用这篇解释为什么要组件化<a href="http://www.infoq.com/cn/articles/front-end-component-develop-and-application-in-react-native">http://www.infoq.com/cn/articles/front-end-component-develop-and-application-in-react-native</a></li><li>以架构层的组件复用降低工作量</li><li>以组件的规范性保障项目设计的统一性</li><li>以组件的独立性和自治性提升团队协同效率</li></ul><h3 id="Vue如何实现组件化"><a href="#Vue如何实现组件化" class="headerlink" title="Vue如何实现组件化"></a>Vue如何实现组件化</h3><ul><li><a href="https://cn.vuejs.org/v2/guide/components.html">https://cn.vuejs.org/v2/guide/components.html</a></li><li>组件是自定义元素:<my-component></my-component></li><li>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来</li></ul><h2 id="核心插件"><a href="#核心插件" class="headerlink" title="核心插件"></a>核心插件</h2><p>最后分享几个Vue核心插件的地址：</p><ul><li>前后端分离、单页、路由<br>vue-router 2：<a href="https://router.vuejs.org/zh-cn/">https://router.vuejs.org/zh-cn/</a></li><li>状态管理<br>Vuex ：<a href="https://vuex.vuejs.org/zh-cn/intro.html">https://vuex.vuejs.org/zh-cn/intro.html</a></li><li>与服务端交互<br>vue-resource：<a href="https://github.com/pagekit/vue-resource">https://github.com/pagekit/vue-resource</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重庆</title>
    <link href="/2017/01/02/life/travelCq/"/>
    <url>/2017/01/02/life/travelCq/</url>
    
    <content type="html"><![CDATA[<h2 id="当代人文"><a href="#当代人文" class="headerlink" title="当代人文"></a>当代人文</h2><p>重庆是山城，首先一个山字，就意味着发展受交通限制。打车直线距离显示10分钟就能到，可能要开1个钟头，路都是曲流拐弯高高低低，住惯了平原的我心烦的很，还被迫买一双运动鞋。<br>如此山城，亦有地铁，它有时是地铁有时是轻轨，有一站直接穿过了一栋楼，有趣的很，在电影《从你的全世界路过》里多次上镜，算是网红地铁吧。<br>正是因为交通的限制，更显得重庆的繁华弥足珍贵。从城市热力图来看，重庆算是内陆明亮的一颗星了。渝中区CBD高楼林立，商铺营业到很晚，跨年夜漫天遍地大学生，解放碑广场犹如白昼。重庆不辱没直辖市的称号，房价却不高，据当地人说得益于薄执政时大力推广公租房的政策。<br>元旦的重庆雾蒙蒙的，一腔心事延绵的样子，不知是嘉陵和长江的无语凝噎，是歌乐山革命英烈的哀怨，还是文艺青年们不可释怀的的忧伤，总是一副清淡寡欢的样子。</p><h2 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h2><h3 id="火锅"><a href="#火锅" class="headerlink" title="火锅"></a>火锅</h3><p>北方的叫涮羊肉，重庆的才叫火锅，火锅必点菜品一定不同于涮羊肉，我来推荐几个：竹笋、竹荪、毛肚、鸭血、鸭肠、菌菇。街上常碰见挑着扁担卖竹笋的货郎，我没有考证元旦是否正是竹笋收获的季节，总之我吃到的是这辈子最好吃的竹笋，嘎嘣脆，爽口极了。<br>重庆火锅必配油碟，油里还要放勺蒜，从锅里夹一筷子美食，往油碟里一蘸，即降温又提味。<br>另外，一定要点一盘当地的酥肉，不同于井格这类连锁店，当地酥肉里搅和了许多麻椒，别具一番风味。<br>我去吃火锅的地方比较随意，是从美团上查的评分较高，离住所又近的地方，据当地人说朝天门的火锅比较受游客欢迎。<br><img src="/assets/life/travel-cq/hg.jpeg" alt="重庆美食"><br><img src="/assets/life/travel-cq/sr.jpeg" alt="重庆美食"></p><h3 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h3><p>当地出租车司机推荐了小滨楼，在一个商场的n层，环境优雅，顾客很多。重庆小面、酸辣粉、红油抄手等等四川小吃在这里都可以吃到，跟成都的龙抄手大概是一个意思。<br><img src="/assets/life/travel-cq/xc.jpeg" alt="重庆美食"><br><img src="/assets/life/travel-cq/xc2.jpeg" alt="重庆美食"></p><h3 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h3><p>路边小推车的串串，写到这里不由的吞了个口水，又像烧烤又像铁板烧，很辣很过瘾，不知是不是因为用的佐料更地道，小摊会营业到夜里一两点，完全不辱没重庆不夜城的名号。</p><h2 id="景色"><a href="#景色" class="headerlink" title="景色"></a>景色</h2><h3 id="洪崖洞"><a href="#洪崖洞" class="headerlink" title="洪崖洞"></a>洪崖洞</h3><p><img src="/assets/life/travel-cq/hyd.jpeg" alt="重庆美食"></p><h3 id="千厮门嘉陵江大桥"><a href="#千厮门嘉陵江大桥" class="headerlink" title="千厮门嘉陵江大桥"></a>千厮门嘉陵江大桥</h3><p><img src="/assets/life/travel-cq/qiao.jpeg" alt="重庆美食"></p><h3 id="解放碑"><a href="#解放碑" class="headerlink" title="解放碑"></a>解放碑</h3><p><img src="/assets/life/travel-cq/jfb.jpeg" alt="重庆"></p><h3 id="爬上南山看夜景"><a href="#爬上南山看夜景" class="headerlink" title="爬上南山看夜景"></a>爬上南山看夜景</h3><p><img src="/assets/life/travel-cq/ns.jpeg" alt="重庆"></p><h3 id="清淡寡欢的重庆"><a href="#清淡寡欢的重庆" class="headerlink" title="清淡寡欢的重庆"></a>清淡寡欢的重庆</h3><p><img src="/assets/life/travel-cq/jiang.jpeg" alt="重庆"></p>]]></content>
    
    
    <categories>
      
      <category>旅行</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-ES5（脚本ing）</title>
    <link href="/2016/11/15/fe/jses5/"/>
    <url>/2016/11/15/fe/jses5/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><h2 id="技巧累计"><a href="#技巧累计" class="headerlink" title="技巧累计"></a>技巧累计</h2><p>1．JS变量声明的正解：先声明后读写，先赋值后运算<br>2．作用域优先级：局部变量&gt;参数变量&gt;全局变量<br>3．字符串+数值：数值转换成字符串再拼接；数值型字符串-0：字符串转换成数字再计算<br>关系运算中null与undefined相等，NaN与任何值不相等，包括自身，null 表示一个值被定义了，定义为“空值”；undefined 表示根本不存在定义。null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。<br>4．for-in循环输出对象的属性，但顺序不可预知，对象的值不能是null和undefined<br>5．!空字符串、!0、!null、NaN、!undefined均等于true；连续两次使用！,可将任意类型转为布尔值，!!’’、!!null、!!0、!!undefined、!!NaN均等于false，巧用！、&amp;&amp;和||可以忽略0、null、undefined、NaN、空字符串<br>6．switch用法：<br>switch(a) {<br>     case 1:<br>        console.log(‘1’);<br>        break;<br>     case 2:<br>        console.log(‘2’);<br>        break;<br>     default:<br>        console.log(‘default’);<br>}<br>a&#x3D;1输出1，a&#x3D;2输出2，a&#x3D;3输出default<br>7．异常处理语句：<br>function myFunction(x) {<br>    try {<br>        if(x &#x3D;&#x3D; “”) throw “是空的”;<br>        if(isNaN(x)) throw “不是数字”;<br>         x &#x3D; Number(x);<br>        if(x &gt;  10) throw “太大”;<br>        if(x &lt;  5) throw “太小”;<br>    }<br>    catch(err) {<br>        console.log(“错误：” + err + “.”);<br>    }<br>    finally {<br>        console.log(‘无论 try &#x2F; catch 结果如何都执行的代码块’);<br>        }<br>}<br>finally需要注意两点：<br>1、finally主要是try块发生异常时，进行一些资源的关闭工作，比如loading。你有可能不会catch掉所有的异常，这个时候finally就有用了<br>2、finally「覆盖」控制流，在finally子句执行之前，解释器会将匹配到的控制跳转先pending不执行，尝试执行finally，而如果finally里有跳转则直接执行且忽略之前任何跳转行为。 Return、break、continue、throw都不会影响finally的执行</p>]]></content>
    
    
    <categories>
      
      <category>前端栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS（装饰）</title>
    <link href="/2016/05/15/fe/css/"/>
    <url>/2016/05/15/fe/css/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>CSS（Cascading Style Sheets层叠样式表）是用来装饰网页的解释型语言。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>属于浏览器解释型语言，可以直接由浏览器执行，不需要编译。<br>内容与表现分离，有了CSS，网页的内容(XHTML)与表现就可以分开了。<br>使用CSS可以减少网页的代码量，增加网页的浏览速度。</p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><p>CSS语法由三部分构成：选择器、属性和值： selector {property: value}<br>详情参见：<a href="https://www.w3cschool.cn/css">https://www.w3cschool.cn/css</a></p><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>CSS Preprocessor是定义一种新的语言，本质上包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的css文件。</p><h4 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h4><p>为了提高CSS的编程性，从而提高开发和维护效率。主要解决的痛点是选择器无法递归定义，没有变量模式，为了解决浏览器的兼容问题会产生很多的冗余代码。</p><h4 id="怎么办-1"><a href="#怎么办-1" class="headerlink" title="怎么办"></a>怎么办</h4><p>sass：<a href="https://www.sass.hk/">https://www.sass.hk/</a><br>less：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a></p><h2 id="最IN的CSS3"><a href="#最IN的CSS3" class="headerlink" title="最IN的CSS3"></a>最IN的CSS3</h2><p>浏览器的可用性同HTML5：<a href="http://caniuse.com/">http://caniuse.com</a></p><h3 id="弹性盒布局："><a href="#弹性盒布局：" class="headerlink" title="弹性盒布局："></a>弹性盒布局：</h3><p>快速实现响应式布局，不产生间隙问题。<br>1、指定Flex布局：<br>display: -webkit-flex; &#x2F;* Safari *&#x2F;<br>display: flex;<br>2、主轴方向：<br>flex-direction: row | row-reverse | column | column-reverse;<br>3、主轴上对齐方式：<br>justify-content: flex-start | flex-end | center | space-between | space-around;<br>4、交叉轴上对齐方式：<br>align-items: flex-start | flex-end | center | baseline | stretch;<br>5、单个子元素的交叉轴对齐方式：<br>.item {<br>  align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>}<br>详情参见：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><h2 id="技巧累计"><a href="#技巧累计" class="headerlink" title="技巧累计"></a>技巧累计</h2><h3 id="高频"><a href="#高频" class="headerlink" title="高频"></a>高频</h3><p>1、背景图像中心与其元素的中心对齐：background-position:50% 50%;<br>2、文本缩进：text-indent:50px;<br>3、font-size应大于12px<br>4、去掉列表项标记ul.a {list-style-type: none;}<br>5、边框属性简写：border:5px solid red;<br>6、隐藏元素 - display:none或visibility:hidden。visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。<br>7、元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。<br>clear 属性指定元素两侧不能出现浮动元素。.text_line{clear:both;}</p><h3 id="外边距塌陷"><a href="#外边距塌陷" class="headerlink" title="外边距塌陷"></a>外边距塌陷</h3><p>两个正常流中，相邻的块级元素（父子或兄弟）上下外边距叠在一起，发生塌陷</p>]]></content>
    
    
    <categories>
      
      <category>前端栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML（结构）</title>
    <link href="/2016/04/15/fe/html/"/>
    <url>/2016/04/15/fe/html/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>HTML（Hypertext Marked Language超文本标记语言）是用来描述网页结构和表现的语言，是一种超文本标记语言，而不是编程语言。多用HTML描述网页结构，由CSS来装饰各个节点的表现。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>Web浏览器（如谷歌浏览器、Internet Explorer、Firefox 和 Safari ）可以将HTML文件解析成可视化的网页。与此相关的便是浏览器的工作原理。而HTML5具有超集方式的简易性、运用广泛的可拓展性、灵活应变的平台适应性以及简单的通用性。凭借着这些特性，HTML越来越受到人们的喜爱。</p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><p>基本结构<br>DOCTYPE声明了文档的类型<br>html标签是 HTML 页面的根元素<br>head标签包含了文档的元数据（meta），如meta charset&#x3D;”utf-8”定义网页编码格式为utf-8。<br>title标签定义文档的标题<br>body标签定义文档的主体，即网页可见的页面内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;页面标题(w3cschool.cn)&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;header&gt;</span><br><span class="line">            &lt;h1&gt;HTML5学习页面&lt;/h1&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;是什么&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;example.html&quot;&gt;为什么&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;service_one.html&quot;&gt;怎么办&lt;/a&gt;&lt;/li&gt;          </span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;aboutus_one.html&quot;&gt;难点&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/nav&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">        &lt;aside&gt;</span><br><span class="line">            &lt;h4&gt;侧边栏&lt;/h4&gt;</span><br><span class="line">            &lt;p&gt;这是一个侧边栏&lt;/p&gt;</span><br><span class="line">        &lt;/aside&gt;</span><br><span class="line">        &lt;article&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">            div：应用广泛，任意一个区域</span><br><span class="line">            section：包含的内容是一个明确的主题，通常有标题区域</span><br><span class="line">            article：如果我们的页面中需要一个单独的模块来实现一个单独的功能，就用article，其他的时section</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;figure&gt;</span><br><span class="line">                    &lt;img src=&quot;img_pulpit.jpg&quot; alt=&quot;The Pulpit Rock&quot; width=&quot;304&quot; height=&quot;228&quot;&gt;</span><br><span class="line">                    &lt;figcaption&gt;figure：图片等流figcaption：图片的主题&lt;/figcaption&gt;</span><br><span class="line">                  &lt;/figure&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">        &lt;footer&gt;</span><br><span class="line">          &lt;p&gt;&lt;time pubdate datetime=&quot;2012-03-01&quot;&gt;&lt;/time&gt;&lt;/p&gt;</span><br><span class="line">        &lt;/footer&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>标签的用法参照：<a href="https://www.w3cschool.cn/html5/html5-intro.html">https://www.w3cschool.cn/html5/html5-intro.html</a></p><h2 id="最IN的HTML5"><a href="#最IN的HTML5" class="headerlink" title="最IN的HTML5"></a>最IN的HTML5</h2><h3 id="HTML5特性"><a href="#HTML5特性" class="headerlink" title="HTML5特性"></a>HTML5特性</h3><p>1、语义特性(Class：Semantic)<br>HTML5赋予网页更好的意义和结构。更加丰富的标签将随着对RDFa的，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。<br>2、本地存储特性(Class: OFFLINE &amp; STORAGE)<br>基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于HTML5 APP Cache，以及本地存储功能。Indexed DB(html5本地存储最重要的技术之一)和API说明文档。<br>3、设备兼容特性 (Class: DEVICE ACCESS)<br>从Geolocation功能的API文档公开以来，HTML5为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。<br>4、连接特性(Class: CONNECTIVITY)<br>更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。<br>5、网页多媒体特性(Class: MULTIMEDIA)<br>支持网页端的Audio、Video等多媒体功能， 与网站自带的APPS，摄像头，影音功能相得益彰。<br>6、三维、图形及特效特性(Class: 3D, Graphics &amp; Effects)<br>基于SVG、Canvas、WebGL及CSS3的3D功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。<br>7、性能与集成特性(Class: Performance &amp; Integration)<br>没有用户会永远等待你的Loading——HTML5会通过XMLHttpRequest2等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。</p><h3 id="HTML5的优势有哪些"><a href="#HTML5的优势有哪些" class="headerlink" title="HTML5的优势有哪些?"></a>HTML5的优势有哪些?</h3><p>1、跨平台性<br>　　在HTML5到来之前，由于平台的多样性，导致每开发一套产品，就要针对不同的平台开发多套版本，耗费大量的时间和精力，而且还增加了大量的开发成本，而HTML5技术的出现却能很好的解决这个问题，开发者只要使用一套程序，就能够很容易的实现多个平台的展现功能，降低了开发难度，节约了开发时间和成本的投入。<br>2、即时更新<br>之前原生应用上线Appstore，都需要等待很长的审核时间，一旦出现问题需要更新，则还要重新审核，无形中浪费了大量的时间。而HTML5是通过浏览器进行加载的，所以不存在这样的问题，如果出现什么问题，可以及时的更新上线，不需要等待审核时间。<br>3、离线缓存功能<br>HTML5中最酷的特性就是离线缓存。通过JavaScript提供了数种不同的离线储存功能，相对于传统的Cookie而言有更好的弹性以及架构，并且可以储存更多的内容。它拥有更好的安全和性能，即使浏览器关闭后也可以保存。<br>使用参考：<a href="https://zhuanlan.zhihu.com/p/21837045">https://zhuanlan.zhihu.com/p/21837045</a><br>4、视频和音频的支持<br>之前在实现播放媒体功能时，一直是开发者比较痛苦的事情，需要让你的视频和音频通过HTML5标签和来访问资源。并且为了它们能正确播放必须赋予一大堆的参数。这样你就要不断的重复标签，你的代码也会变得十分繁琐。现在，这一切都将变的非常简单。<br>5、清晰的代码<br>HTML5可以让你写出简单清晰的代码。使用HTML5你可以通过使用语义学的HTML header标签描述内容来最后解决你的div及其class定义问题。让你的代码更加清晰易于理解。<br>6、现在就用HTML5<br>截至目前而言，主流的网页浏览器Firefox5、Chrome 12和Safari 5都已经支援了许多的HTML5标准，而且目前最新版的IE也支援了许多HTML5标准，随着使用者陆续升级到新版的浏览器，开发者应该在现在就可以招收开发!兼容性问题会随着时间的推移而越来越少。但对于不得不照顾低版本用户的网站，网上也有大量的相关解决方案。</p><h3 id="HTML5的支持情况"><a href="#HTML5的支持情况" class="headerlink" title="HTML5的支持情况"></a>HTML5的支持情况</h3><p>localStorage、sessionStorage、placeholder浏览器的支持情况比较好了。在<a href="http://caniuse.com上,我们可以查询html5里具体功能在各个浏览器下的支持情况./">http://caniuse.com上，我们可以查询HTML5里具体功能在各个浏览器下的支持情况。</a><br>各浏览器装机情况统计:<br>在<a href="http://gs.statcounter.com上,可以查看各浏览器占有率(也可以精确到具体版本),还可以选择时间段、地区查询./">http://gs.statcounter.com上，可以查看各浏览器占有率（也可以精确到具体版本），还可以选择时间段、地区查询。</a></p><h2 id="技巧累计"><a href="#技巧累计" class="headerlink" title="技巧累计"></a>技巧累计</h2><h3 id="HTML速查列表"><a href="#HTML速查列表" class="headerlink" title="HTML速查列表"></a>HTML速查列表</h3><p><a href="https://www.w3cschool.cn/html/html-quicklist.html">https://www.w3cschool.cn/html/html-quicklist.html</a></p><h3 id="CSS和JS"><a href="#CSS和JS" class="headerlink" title="CSS和JS"></a>CSS和JS</h3><p>在html页面应用css有内联、内嵌、外部三种，其中外部样式的引入如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot;&gt;</span><br><span class="line">//相对绝对地址均可</span><br></pre></td></tr></table></figure><p>css不会产生阻塞<br>在html页面应用js有内联、外部、元素属性三种，其中外部样式的引入如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;script/default.js&quot; type=&quot;text/javascript&quot;&gt;</span><br></pre></td></tr></table></figure><p>html的解析遇到script标签会暂停解析，转而下载script资源，下载完成后执行script，再恢复文档的解析和渲染<br>所以推荐js资源再最后引入，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    ......</span><br><span class="line">    &lt;script src=&quot;script/default.js&quot; type=&quot;text/javascript&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/html/deferasync.png" alt="deferasync"><br>为了解决script的阻塞问题，script新增了两个属性，分别是延迟（defer）和异步（async）</p><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>块级元素：hx、p、ul、dl、ol、table、div<br>行内元素：a、img、li、span<br>空元素：br<br>默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。<br>HTML 代码中的所有连续的空行（换行）也被显示为一个空格。<br>最常用的元素div和span将元素组合起来，两者无意义，专用布局，H5提倡用语义化标签代替它</p><h3 id="mata标签"><a href="#mata标签" class="headerlink" title="mata标签"></a>mata标签</h3><p>meta标签可以定义的元数据有四种：<br>1、声明文档内容的所用编码charset&#x3D;”utf-8”<br>2、完善文档描述信息，让搜索引擎更容易解析索引，提升SEO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;application-name&quot; content=&quot;TOOl&quot;&gt;</span><br></pre></td></tr></table></figure><p>3、适配移动设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;</span><br><span class="line">&lt;!--移动端兼容适配 --&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">// class </span><br><span class="line">! function( navigator ) &#123; </span><br><span class="line">var userAgent = navigator.userAgent; </span><br><span class="line">documentElement = document.documentElement; </span><br><span class="line">if ( userAgent.match( /micromessenger\/5/gi ) ) &#123; </span><br><span class="line">documentElement.className += &quot; mobile wx_mobile wx_mobile_5&quot;; </span><br><span class="line">&#125; else if ( userAgent.match( /micromessenger/gi ) ) &#123; </span><br><span class="line">documentElement.className += &quot; mobile wx_mobile&quot;; </span><br><span class="line">&#125; else if ( userAgent.match( /ucbrowser/gi ) ) &#123; </span><br><span class="line">documentElement.className += &quot; mobile uc_mobile&quot;; </span><br><span class="line">&#125; else if ( /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test( userAgent.toLowerCase() ) ) &#123; </span><br><span class="line">documentElement.className += &quot; mobile&quot;; </span><br><span class="line">&#125; else if ( userAgent.toLowerCase().match( /msie/gi ) &amp;&amp; ( parseFloat( userAgent.toLowerCase().match( /msie ([0-9]&#123;1,&#125;[\.0-9]&#123;0,&#125;)/i )[1] || 999 ) &lt; 9 ) ) &#123; </span><br><span class="line">documentElement.className += &quot; pc pc-ie pc-ie8&quot;; </span><br><span class="line">&#125; else if ( userAgent.toLowerCase().match( /msie/gi ) || navigator.msPointerEnabled || navigator.pointerEnabled ) &#123; </span><br><span class="line">documentElement.className += &quot; pc pc-ie&quot;; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">documentElement.className += &quot; pc&quot;;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;( navigator ); </span><br><span class="line">// meta </span><br><span class="line">! function( userAgent ) &#123; </span><br><span class="line">var screen_w = parseInt(window.screen.width), </span><br><span class="line">scale = screen_w / 640; </span><br><span class="line">if ( /Android (\d+\.\d+)/.test( userAgent ) ) &#123; </span><br><span class="line">var version = parseFloat( RegExp.$1 ); </span><br><span class="line">document.write( version &gt; 2.3 </span><br><span class="line">? &#x27;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, minimum-scale = &#x27; + scale + &quot;, maximum-scale = &quot; + scale + &#x27;, target-densitydpi=device-dpi&quot;&gt;&#x27; </span><br><span class="line">: &#x27;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, target-densitydpi=device-dpi&quot;&gt;&#x27; ); </span><br><span class="line">&#125; else &#123; </span><br><span class="line">document.write( &#x27;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&#x27; ); </span><br><span class="line">&#125; </span><br><span class="line">&#125;( navigator.userAgent ); </span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;!--移动端兼容适配 end --&gt;</span><br></pre></td></tr></table></figure><p>4、指定首选样式表、执行重载或重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;default-style&quot; content=&quot;red&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>默认的被链接文档会在原有的窗口中打开的。如果将 target 属性设置为 “_blank” 则文档就会在新窗口打开。<br>href标签中可写相对地址、可写绝对地址（需写全协议）</p><h3 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h3><p>img元素是自关闭元素，不需要结束标记。<br>img标签有两个必需的属性：src和alt。<br>usemap属性让图像关联分区域响应<br>H5新增属性crossorigin帮助图像可以跨域，主要用于canvas</p><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>H5新增属性：placeholder、autocomplete(控制浏览器自动填充)、required等<br>disabled属性把表单提交时并不发送数据，readonly表单提交时会发送数据</p><h3 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a>table标签</h3><p>没有语义化、自适应性差、可维护性差</p><h3 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h3><p>iframe会阻塞页面加载，极度拉长首屏显示时间，可以制造点击劫持等，非必要不使用。需要使用的场景如下：<br>1、Hybrid App中常用的JSBridge，通过动态添加iframe元素，再定义src属性，最后发起请求来唤起某个功能<br>2、嵌入广告等第三方内容<br>3、跨域通信<br>4、实现长轮询（将被H5的WebSocket取代）<br>5、无刷新文件上传</p>]]></content>
    
    
    <categories>
      
      <category>前端栈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
